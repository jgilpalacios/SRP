let autorun = [
    {
      "nombre": "autorun0",
      "contenido": "# version: SRP v1.1 #\n\n# Nombre del dispositivo que contiene el sistema de backup\nBACKUP_DEV=\"/dev/sda9\"\n# Punto de montaje de la partición de backup\nBACKUP_MNT=\"/mnt/backup\"\n# Número de grupos de particiones\nNG=3\n\n###############################################################################\n# Número de particiones que tiene el grupo x\n#Gx_NP=n\n# Etiqueta del grupo. Esta etiqueta se mostrará en los menus, en mensajes tipo:\n# Restaurar <ETIQUETA>...\n# Generar backup de <ETIQUETA>...\n#Gx_MENU=\"Linux\"\n#------------------------------------------------------------------------------\n# Nombre dispositivo\n#GxPn_DEV=\"/dev/sda1\"\n# Etiqueta que se muestra en los menus\n#GxPn_MENU=\"MAX\"\n# Etiqueta del sistema de ficheros\n#GxPn_LABEL=\"MAX65\"\n# Sistema de ficheros\n#GxPn_FS=\"ntfs\"\n###############################################################################\nG1_NP=3\nG1_MENU=\"Windows\"\n#------------------------------------------------------------------------------\nG1P1_DEV=\"/dev/sda1\"\nG1P1_MENU=\"\"\nG1P1_LABEL=\"Reservado para el sistema\"\nG1P1_FS=\"ntfs\"\n#------------------------------------------------------------------------------\nG1P2_DEV=\"/dev/sda4\"\nG1P2_LABEL_MENU=\"Windows\"\nG1P2_LABEL=\"Windows11\"\nG1P2_FS=\"ntfs\"\n#------------------------------------------------------------------------------\nG1P3_DEV=\"/dev/sda5\"\nG1P3_MENU=\"\"\nG1P3_LABEL=\"Reservado para el sistema 2\"\nG1P3_FS=\"ntfs\"\n###############################################################################\nG2_NP=2\nG2_MENU=\"MAX\"\n#------------------------------------------------------------------------------\nG2P1_DEV=\"/dev/sda6\"\nG2P1_LABEL_MENU=\"MAX\"\nG2P1_LABEL=\"MAX12\"\nG2P1_FS=\"ext4\"\n#------------------------------------------------------------------------------\n# Asignar a G2P2_DEV la etiqueta \"no_hay_swap\" para indicar que no existe swap.\nG2P2_DEV=\"/dev/sda7\"\nG2P2_LABEL_MENU=\"\"\nG2P2_LABEL=\"swap\"\nG2P2_FS=\"swap\"\n###############################################################################\nG3_NP=1\nG3_MENU=\"Datos\"\n#------------------------------------------------------------------------------\nG3P1_DEV=\"/dev/sda5\"\nG3P1_LABEL_MENU=\"Datos\"\nG3P1_LABEL=\"Datos\"\nG3P1_FS=\"ntfs\"\n###############################################################################\nG4_NP=1\nG4_MENU=\"EFI\"\n#------------------------------------------------------------------------------\nG4P1_DEV=\"/dev/sda2\"\nG4P1_LABEL_MENU=\"EFI\"\nG4P1_LABEL=\"EFI\"\nG4P1_FS=\"fat32\"\n###############################################################################\n# Verificar si el directorio /mnt/backup existe \nif [ -d \"$BACKUP_MNT\" ]; then\n    echo \"El directorio '$BACKUP_MNT' ya existe.\"\nelse\n    echo \"El directorio '$BACKUP_MNT' no existe. Creándolo ahora...\"\n    mkdir -p \"$BACKUP_MNT\" # Crea el directorio (incluyendo directorios padres si no existen)\n    if [ $? -eq 0 ]; then\n        echo \"Directorio creado exitosamente.\"\n    else\n        echo \"Hubo un error al crear el directorio.\"\n    fi\nfi\n"
    },
    {
      "nombre": "autorun1",
      "contenido": "#!/bin/bash\n\n# autorun1 : Monta la partición de backup\n\n. /run/archiso/bootmnt/autorun/autorun0\necho \"Montando la partición de backup \\\"$BACKUP_DEV\\\" en \\\"$BACKUP_MNT\\\"...\"\nmount $BACKUP_DEV $BACKUP_MNT\n"
    },
    {
      "nombre": "autorun2",
      "contenido": "#!/bin/bash\n\n# autorun2 : Cambiar el tiempo de espera\n\n. /run/archiso/bootmnt/autorun/autorun0\n\ngrubcfg=\"$BACKUP_MNT/srp/menus/menuprincipal.cfg\"\nclear\necho\necho\necho \"Introduzca el tiempo de espera(segundos) que quiere hasta que\"\necho \"se inicie el sistema operativo por defecto.\"\necho \"El mínimo valor que se puede introducir es 1 y el máximo 100.\"\necho \"Si no quiere tiempo de espera y prefiere que el menú se detenga\"\necho \"hasta seleccionar una opción introduzca 0.\"\necho\ndeclare -i tiempo=101\nwhile (( $tiempo > 100)) ; do\n   echo -n \"Tiempo de espera: \"\n   read tiempo \n   echo\ndone\ncad_antigua=$(cat $grubcfg | grep -e \"timeout=\")\nif (( $tiempo == 0 )) ; then\n   # En grub realmente el valor 0 para timeout hace que se oculte el menu y sea necesario pulsar shift\n   # pero aqui hacemos que si se elije 0 el tiempo quede desactivado. \n   cad_nueva=$(echo \"#timeout=$tiempo\")\nelse\n   cad_nueva=$(echo \"timeout=$tiempo\")\nfi\nsed -i \"s/$cad_antigua/$cad_nueva/\" $grubcfg\necho \"################################################################################\"\necho \"        ¡ ¡ ¡ TIEMPO DE ESPERA CAMBIADO ! ! !  Reiniciando el sistema...        \"\necho \"################################################################################\"\nsleep 2\nreboot\n"
    },
    {
      "nombre": "autorun3",
      "contenido": "#!/bin/bash\n\n# autorun3 : Cambiar el S.O. seleccionado en el menú\n\n. /run/archiso/bootmnt/autorun/autorun0\n\ngrubcfg=\"$BACKUP_MNT/srp/menus/menuprincipal.cfg\"\nclear\necho\necho\necho \"Introduzca el NUMERO del sistema operativo que quiere quede seleccionado\"\necho \"por defecto en el menú de inicio, según la siguiente relación:\"\necho\necho \" 0 = Iniciar Windows\"\necho \" 1 = Iniciar MAX\"\necho\ndeclare -i so=2\nwhile (( $so < 0 || $so > 1 )) ; do\n   echo -n \"Introduzca un número: \"\n   read so\n   echo\ndone\ncad_antigua=$(cat $grubcfg | grep -e \"default=\")\ncad_nueva=$(echo \"default=$so\") \nsed -i \"s/$cad_antigua/$cad_nueva/\" $grubcfg\necho \"################################################################################\"\necho \"      ¡ ¡ ¡ O P C I O N  C A M B I A D A ! ! !  Reiniciando el sistema...       \"\necho \"################################################################################\"\nsleep 2\nreboot\n"
    },
    {
      "nombre": "autorun4",
      "contenido": "#!/bin/bash\n# autorun4 : Restaura partición de Windows\nclear\n. /run/archiso/bootmnt/autorun/autorun0\n. /run/archiso/bootmnt/autorun/funciones.sh\necho \"################################################################################\"\necho \" autorun4:              R E S T A U R A R  W I N D O W S                        \"\necho \"################################################################################\"\nf_dir_copia COPIA\nestoy_vivo pid_estoy_vivo\nif [ ! -d \"$BACKUP_MNT/$COPIA\" ] ; then\n   echo \"ERROR: No existe el directorio de la copia: $BACKUP_MNT/$COPIA\"\n   proceso_terminado 1\n   exit 1\nfi\n##--particion recuperacion windows--##\nif [ ! -f \"$BACKUP_MNT/$COPIA/img_win_system.gz\" ] ; then\n   echo \"ERROR: No se encontró el fichero: $BACKUP_MNT/$COPIA/img_win_system.gz\"\n   proceso_terminado 1\n   exit 1\nfi\n##--fin particion recuperacion windows--##\n##--segunda particion recuperacion windows--##\nif [ ! -f \"$BACKUP_MNT/$COPIA/img_win_systemp2.gz\" ] ; then\n   echo \"ERROR: No se encontró el fichero: $BACKUP_MNT/$COPIA/img_win_systemp2.gz\"\n   proceso_terminado 1\n   exit 1\nfi\n##--fin segunda particion recuperacion windows--##\nif [ ! -f \"$BACKUP_MNT/$COPIA/img_win_windows.gz.00\" ] ; then\n   echo \"ERROR: No se encontró el fichero: $BACKUP_MNT/$COPIA/img_win_windows.gz.00\"\n   proceso_terminado 1\n   exit 1\nfi\ngunzip -c \"$BACKUP_MNT/$COPIA/img_win_system.gz\" | partclone.restore -o \"$G1P1_DEV\"\necho \"--------------------------------------------------------------------------------\"\ncat \"$BACKUP_MNT/$COPIA\"/img_win_windows.gz.* | gunzip -c | partclone.restore -o \"$G1P2_DEV\"\necho \"--------------------------------------------------------------------------------\"\ngunzip -c \"$BACKUP_MNT/$COPIA/img_win_systemp2.gz\" | partclone.restore -o \"$G1P3_DEV\"\nkill $pid_estoy_vivo\n# Si se indicó restaurar Windows(autorun4) y MAX(autorun5)\n# no reinicia para que se ejecute el autorun5.\nif [ \"x$(f_parametro_kernel autoruns)\" == \"x1,4\" ] ; then\nproceso_terminado $error\nfi\n"
    },
    {
      "nombre": "autorun5",
      "contenido": "#!/bin/bash\n# autorun5 : Restaura partición de MAX\nif [ \"x$(f_parametro_kernel ar_suffixes)\" != \"x1,4,5\" ] ; then\n#Solo se borra si es restaurar solo MAX\nclear\nfi\n. /run/archiso/bootmnt/autorun/autorun0\n. /run/archiso/bootmnt/autorun/funciones.sh\necho \"################################################################################\"\necho \" autorun5:                   R E S T A U R A R  M A X                           \"\necho \"################################################################################\"\nf_dir_copia COPIA\nestoy_vivo pid_estoy_vivo\nif [ ! -d \"$BACKUP_MNT/$COPIA\" ] ; then\n   echo \"ERROR: No existe el directorio: $BACKUP_MNT/$COPIA\"\n   proceso_terminado 1\n   exit 1\nfi\nif [ ! -f \"$BACKUP_MNT/$COPIA/img_max.gz.00\" ] ; then\n   echo \"ERROR: No existe el fichero: $BACKUP_MNT/$COPIA/img_max.gz.00\"\n   proceso_terminado 1\n   exit 1\nfi\ncat \"$BACKUP_MNT\"/\"$COPIA\"/img_max.gz.* | gunzip -c | partclone.restore -o \"$G2P1_DEV\"\necho \"--------------------------------------------------------------------------------\"\n#configuramos la particion swap con los datos recogidos al hacer el backup en $BACKUP_MNT/$COPIA/autorun5_swap\n#mkswap -U 2aaf006f-c508-4d04-8b68-1ec503a746f8 /dev/sda7\n#leemos el contenido del archivo\ncomando_swap=$(cat \"$BACKUP_MNT\"/\"$COPIA\"/autorun5_swap)\n#ejecutamos el comando para la swap\necho \"Ejecutamos: $comando_swap\" \neval \"$comando_swap\"\n\nkill $pid_estoy_vivo\n# Se acaba tanto si es solo MAX como si es Win y MAX\nproceso_terminado 0\n\n"
    },
    {
      "nombre": "autorun6",
      "contenido": "#!/bin/bash\n\n# autorun6 : Generar backup de WINDOWS\n\n#borramos la pantalla\nclear\n\n. /run/archiso/bootmnt/autorun/autorun0\n. /run/archiso/bootmnt/autorun/funciones.sh\n\necho \"################################################################################\"\necho \" autorun6:      G E N E R A N D O  B A C K U P  D E  W I N D O W S              \"\necho \"################################################################################\"\n\n# Guarda en COPIA el directorio de la copia y crea el directorio si no existe.\nf_dir_copia COPIA crea\n\nerror=\"0\"\nestoy_vivo pid_estoy_vivo\n\n# Antes de hacer la copia es conveniente borrar el pagefile.sys y el\n# hiberfil.sys ya que ocupan mucho tamaño y son ficheros que windows\n# los vuelve a crear en el siguiente inicio.\n#primero creamos el directorio /mnt/windows ya que si no se crea expecificamente falla\nmkdir /mnt/windows\nmount -t ntfs-3g \"$G1P2_DEV\" /mnt/windows\nrm /mnt/windows/pagefile.sys 2> /dev/null\nrm /mnt/windows/hiberfil.sys 2> /dev/null\numount /mnt/windows\nrm -f \"$BACKUP_MNT/$COPIA\"/img_win_*\necho \"--------------------------------------------------------------------------------\"\n##--particion recuperacion windows--##\npartclone.ntfs -c -s \"$G1P1_DEV\" | gzip > \"$BACKUP_MNT/$COPIA/img_win_system.gz\"\nerror=$? ; [[ \"$error\" == \"0\" ]] || proceso_terminado $error\n##--fin particion recuperacion windows--##\n##--segunda particion recuperacion windows--##\necho \"--------------------------------------------------------------------------------\"\npartclone.ntfs -c -s \"$G1P3_DEV\" | gzip > \"$BACKUP_MNT/$COPIA/img_win_systemp2.gz\"\nerror=$? ; [[ \"$error\" == \"0\" ]] || proceso_terminado $error\n##--fin segunda particion recuperacion windows--##\necho \"--------------------------------------------------------------------------------\"\npartclone.ntfs -c -s \"$G1P2_DEV\" | gzip | split -d -b2000m - \"$BACKUP_MNT/$COPIA/img_win_windows.gz.\"\nerror=$? ; [[ \"$error\" == \"0\" ]] || proceso_terminado $error\n\nkill $pid_estoy_vivo\nif [ \"x$(f_parametro_kernel ar_suffixes)\" != \"x1,6,7\" ] ; then\n#Si solo es windows se acaba ahora\nproceso_terminado $error\nfi\n\n"
    },
    {
      "nombre": "autorun7",
      "contenido": "#!/bin/bash\n# autorun7 : Generar backup de MAX\nif [ \"x$(f_parametro_kernel ar_suffixes)\" != \"x1,6,7\" ] ; then\n#Si solo es MAX hay que borrar\nclear\nfi\n\n. /run/archiso/bootmnt/autorun/autorun0\n. /run/archiso/bootmnt/autorun/funciones.sh\n\necho \"################################################################################\"\necho \" autorun7:            G E N E R A R  B A C K U P  D E  M A X                    \"\necho \"################################################################################\"\n\n# Guarda en COPIA el directorio de la copia y lo crea si no existe.\nf_dir_copia COPIA crea\n\nestoy_vivo pid_estoy_vivo\n# De la partición swap no se hace imagen, simplemente hay que capturar\n# sus datos como la etiqueta y el UUID para formatearla con los mismos.\n# Al formatear la swap, el UUID es importante que sea el mismo ya que\n# hay distribuciones como Ubuntu que montan la swap haciendo referencia\n# al UUID por lo que si no coincide no la montará.\n\n#verificar si el archivo autorun5_swap existe, si no es así se crea\nif [ ! -f \"$BACKUP_MNT/$COPIA/autorun5_swap\" ]; then\n    echo \"#mkswap no_hay_swap\" > \"$BACKUP_MNT/$COPIA/autorun5_swap\"\n    echo \"El archivo autorun5_swap no existe se crea con el contenido #mkswap no_hay_swap\"\nfi\n\nif [ x${G2P2_DEV} = \"xno_hay_swap\" ] ; then\n   echo \"No hay swap. Modificando \\\"autorun5_swap\\\" para ignorar la swap.\"\n   #sed -i -e \"s/^mkswap.*/#mkswap /\" \"$BACKUP_MNT/autorun5\"\n   sed -i -e \"s/^mkswap.*/#mkswap /\" \"$BACKUP_MNT/$COPIA/autorun5_swap\"\nelse\nlinea_blkid_swap=($(blkid $G2P2_DEV | grep swap))\n# Lineas para probar posibles resultados de \"linea_blkid_swap\":\n# linea_blkid_swap=\"/dev/sda3: LABEL=\\\"MAX6\\\" UUID=\\\"ae535e30-36a9-42be-ada8-3fff8dc17ab4\\\" TYPE=\\\"ext4\\\"\"\n# linea_blkid_swap=\"/dev/sda3: UUID=\\\"ae535e30-36a9-42be-ada8-3fff8dc17ab4\\\" TYPE=\\\"ext4\\\"\"\n# linea_blkid_swap=()\nif [ ${#linea_blkid_swap[*]} = 0 ] ; then\n   echo \"ERROR: No se ha obtenido ninguna información de la swap.\"\n   echo \"       \\\"blkid $G2P2_DEV | grep swap\\\" ha devuelto una cadena vacía.\"\n   proceso_terminado 1\nfi\nfor cadena in ${linea_blkid_swap[*]} ; do\n   campo=$(echo \"$cadena\" | cut -d = -f 1)\n   case $campo in\n      # La siguiente linea la anulamos ya que la swap la establecemos directamente en la variable G2P2_DEV\n      # \"/dev/sda\"[0-9]*\":\") DEV_swap=$(echo \"$cadena\" | tr -d :);;\n      \"LABEL\") LABEL_swap=$(echo \"$cadena\" | cut -d = -f 2 | tr -d \\\");; \n      \"UUID\" ) UUID_swap=$(echo \"$cadena\" | cut -d = -f 2 | tr -d \\\");; \n      \"TYPE\" ) TYPE_swap=$(echo \"$cadena\" | cut -d = -f 2 | tr -d \\\");; \n   esac\ndone\n\n# Comprobamo que G2P2_DEV es un dispositivo válido.\necho \"$G2P2_DEV\" | grep -x \"/dev/sd[a-z][0-9]\\+\" > /dev/null\nif [ $? != 0 ] ; then\n   echo \"ERROR: No se ha encontrado un disposivo válido para la swap\"\n   echo \"       La variable \\\"G2P2_DEV\\\" ha devuelto: $G2P2_DEV\"\n   proceso_terminado 1 \nfi\n\n# Se comprueba que el formato del UUID sea correcto, por ejemplo:\n# UUID_swap=\"6c22d2a9-0683-4ecf-a633-21b840de614a\"\necho \"$UUID_swap\" | grep -x \"........-....-....-....-............\" > /dev/null\nif [ $? != 0 ] ; then\n   echo \"ERROR: No se ha encontrado un UUID válido para la \\\"swap\\\".\"\n   echo \"       El UUID devuelto ha sido......: $UUID_swap\"\n   echo \"       Se esperaba un patrón del tipo: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\"\n   proceso_terminado 1\nfi \n\n# Se comprueba que el tipo de la partición es \"swap\"\nif [ x\"$TYPE_swap\" != \"xswap\" ] ; then\n   echo \"ERROR: Se esperaba el tipo \\\"swap\\\" para la partición de intercambio.\"\n   echo \"       El valor devuelto por TYPE_swap ha sido: $TYPE_swap\"\n   proceso_terminado 1\nfi\n\necho \"--------------------------------------------------\"\necho \"Datos de la swap:\"\necho \"   DEVICE.....: $G2P2_DEV\"\necho \"   LABEL......: $LABEL_swap\"\necho \"   UUID.......: $UUID_swap\"\necho \"   TYPE.......: $TYPE_swap\"\necho \"--------------------------------------------------\"\necho \n# Ya tenemos todos los datos de la swap, se modifica el script que restaura la imagen\n# de linux para que formatee la swap con los mismos datos.\nlinea_mkswap=$(cat \"$BACKUP_MNT/$COPIA/autorun5_swap\" | grep -e \"^mkswap \" -e \"^#mkswap \")\nif [ -z \"$linea_mkswap\" ] ; then\n   echo \"ERROR: El script $BACKUP_MNT/$COPIA/autorun5_swap\"\n   echo \"       no contiene una línea que empiece con \\\"mkswap \\\" o \\\"#mkswap \\\".\" \n   proceso_terminado 1\nfi\n\n# Al comando sed no se le pueden pasar barras directamente ya que es su separador\n# por eso hay que pasarle el G2P2_DEV modificado\nDEV_swap_barra=$(echo $G2P2_DEV | sed --posix s/\\\\//\\\\\\\\\\\\//g)\n# Se modifica la orden mkswap dependiendo de si la swap tiene o no etiqueta\nif [ -z \"$LABEL_swap\" ] ; then\n   # La swap no tiene etiqueta\n   ! ( sed -i -e \"s/^mkswap .*/mkswap -U $UUID_swap $DEV_swap_barra/\" \"$BACKUP_MNT/$COPIA/autorun5_swap\" ) || sed -i -e \"s/^#mkswap .*/mkswap -U $UUID_swap $DEV_swap_barra/\" \"$BACKUP_MNT/$COPIA/autorun5_swap\" \nelse\n   ! ( sed -i -e \"s/^mkswap .*/mkswap -L $LABEL_swap -U $UUID_swap $DEV_swap_barra/\" \"$BACKUP_MNT/$COPIA/autorun5_swap\" ) || sed -i -e \"s/^#mkswap .*/mkswap -L $LABEL_swap -U $UUID_swap $DEV_swap_barra/\" \"$BACKUP_MNT/$COPIA/autorun5_swap\"\nfi\n\nfi\n# Hay que hacer un fsck por que sino partclone da error si la unidad necesita ser chequeada.\nfsck.ext4 -y $G2P1_DEV\nrm -f \"${BACKUP_MNT}/${COPIA}\"/img_max.gz.??\necho \"--------------------------------------------------------------------------------\"\npartclone.extfs -c -s $G2P1_DEV | gzip | split -d -b 2000m - \"${BACKUP_MNT}/${COPIA}\"/img_max.gz.\n\n#se acaba tanto si solo es MAX como si es Windows y MAX\nkill $pid_estoy_vivo\nproceso_terminado $error\n"
    },
    {
      "nombre": "autorun8",
      "contenido": "#!/bin/bash\n\n# autorun8 : Cambiar la contraseña\n\n. /run/archiso/bootmnt/autorun/autorun0\n\ngrubcfg=\"$BACKUP_MNT/srp/menus/menuprincipal.cfg\"\npassword1=\"\"\npassword2=\"x\"\nclear\necho\necho\necho \"Utilize sólo letras y números para la contraseña.\"\necho \"Las letras acentuadas y la letra ñ no son válidas.\"\necho \"Se diferencia entre letras mayúsculas y minúsculas.\"\necho \"Si desea cancelar y no cambiar la contraseña deje la\"\necho \"\\\"Nueva contraseña\\\" en blanco y pulse ENTER, el\"\necho \"equipo se reinciará sin hacer cambios.\"\necho \"No se permite quitar la contraseña, es decir, dejarla\"\necho \"en blanco, es obligatorio que exista una contraseña.\"\necho\nwhile [ x\"$password1\" != x\"$password2\" ] ; do\n   echo -n \"Nueva contraseña : \"\n   read -s password1\n   echo\n   if [ -z $password1 ] ; then\n      echo \"Reiniciando el sistema...\"\n      reboot\n      exit 0\n   fi\n   echo -n \"Repita contraseña: \"\n   read -s password2\n   echo\n   if [ x\"$password1\" != x\"$password2\" ] ; then\n      echo \"ERROR: Las contraseñas no coinciden.\"\n   fi\ndone\n# grub-mkpasswd-pbkdf2 << EOT\n# $password\n# $password\n# EOT\n# if [ $? != 0 ] ; then\n#    echo \"Error al cambiar la contraseña.\"\n#    exit 1\n# fi\ncad_antigua=$(cat $grubcfg | grep -e \"password \")\ncad_nueva=$(echo \"$(echo $cad_antigua | cut -d \" \" -f 1-2) $password1\") \nsed -i \"s/$cad_antigua/$cad_nueva/\" $grubcfg\necho \"###########################################################################\"\necho \"¡ ¡ ¡ C O N T R A S E Ñ A  C A M B I A D A ! ! !  Reiniciando el sistema...\"\necho \"###########################################################################\"\nsleep 2\nreboot\n"
    },
    {
      "nombre": "autorun9",
      "contenido": "#!/bin/bash\n\n# autorun9 : Generar backup de la particion EFI\nclear\n\n. /run/archiso/bootmnt/autorun/autorun0\n. /run/archiso/bootmnt/autorun/funciones.sh\n\necho \"################################################################################\"\necho \" autorun9:      G E N E R A N D O  B A C K U P  D E  la particion E F I         \"\necho \"################################################################################\"\n\n# Guarda en COPIA el directorio de la copia y crea el directorio si no existe.\nf_dir_copia COPIA crea\n\nerror=\"0\"\nestoy_vivo pid_estoy_vivo\n\n#Borra la copia previa\nrm -f \"$BACKUP_MNT/$COPIA\"/img_EFI*\necho \"--------------------------------------------------------------------------------\"\npartclone.fat32 -c -s \"$G4P1_DEV\" | gzip > \"$BACKUP_MNT/$COPIA/img_EFI.gz\"\nerror=$? ; [[ \"$error\" == \"0\" ]] || proceso_terminado $error\necho \"--------------------------------------------------------------------------------\"\n\nkill $pid_estoy_vivo\n\nproceso_terminado $error\n"
    },
    {
      "nombre": "autorunA",
      "contenido": "#!/bin/bash\n# autorunA : Restaura la particion EFI\nclear\n. /run/archiso/bootmnt/autorun/autorun0\n. /run/archiso/bootmnt/autorun/funciones.sh\necho \"################################################################################\"\necho \" autorunA:              R E S T A U R A R  la particion E F I                   \"\necho \"################################################################################\"\nf_dir_copia COPIA\n#estoy_vivo pid_estoy_vivo\nif [ ! -d \"$BACKUP_MNT/$COPIA\" ] ; then\n   echo \"ERROR: No existe el directorio de la copia: $BACKUP_MNT/$COPIA\"\n   proceso_terminado 1\n   exit 1\nfi\nif [ ! -f \"$BACKUP_MNT/$COPIA/img_EFI.gz\" ] ; then\n   echo \"ERROR: No se encontró el fichero: $BACKUP_MNT/$COPIA/img_EFI.gz\"\n   proceso_terminado 1\n   exit 1\nfi\ngunzip -c \"$BACKUP_MNT/$COPIA/img_EFI.gz\" | partclone.restore -o \"$G4P1_DEV\"\necho \"--------------------------------------------------------------------------------\"\n\nkill $pid_estoy_vivo\n\nproceso_terminado $error\n\n"
    },
    {
      "nombre": "autorunB",
      "contenido": "#!/bin/bash\n\n# autorunB : Arraca System Rescue en modo grafico y monta las particiones en /mnt\n\n. /run/archiso/bootmnt/autorun/autorun0\n##--entrada EFI--##\nmkdir /mnt/EFI\necho \"Montando la partición EFI \\\"$G4P1_DEV\\\" en /mnt/EFI ...\"\nmount $G4P1_DEV /mnt/EFI\n\n##--fin entrada EFI--##\nmkdir /mnt/SRP\necho \"Montando la partición SRP \\\"$SRP_DEV\\\" en /mnt/SRP ...\"\nmount $SRP_DEV /mnt/SRP\necho \"SRPBACKUP ya está montaada en \\\"$BACKUP_MNT\\\" ...\"\n\n##--entrada windows--##\nmkdir /mnt/WIN\necho \"Montando la partición windows \\\"$G1P2_DEV\\\" en /mnt/WIN ...\"\nmount $G1P2_DEV /mnt/WIN\n##--fin entrada windows--##\n\n##--entrada MAX--##\nmkdir /mnt/MAX\necho \"Montando la partición MAX \\\"$G2P1_DEV\\\" en /mnt/MAX ...\"\nmount $G2P1_DEV /mnt/MAX\n##--fin entrada MAX--##\n\n## arancamos en modo grafico es necesario poner sudo que arranque como root y funcione bien\nsudo startx\n"
    },
    {
      "nombre": "funciones.sh",
      "contenido": "# funciones.sh\n\n################################################################################\n# Función que obtiene los parámetros con los que fue ejecutado el kernel.\n# Los parámetros del kernel se pueden dividir en dos categorías, los que\n# tienen asociado un valor como por ejemplo \"srp_copia=copia1\" donde el valor\n# está separado por el \"igual\" y los que no tienen asociado ningun valor como\n# por ejemplo \"docache\".\n# A la función se le pasa el nombre del parámetro que se quiere obtener y\n# devuelve (muestra en pantalla) su valor si es de los que tienen asociado uno.\n# Además de mostrar el valor del parámetro retorna el código 0 indicado una\n# ejecución correcta. Si el parámetro es de los que no tiene asociado ningún\n# valor simplemente retorna el código 0 para saber que el parámetro fue\n# encontrado pero no imprime nada. En caso de que no se obtenga un valor para\n# un parámetro que debiera tenerlo o el parámetro no exista, la función no\n# imprime nada y retorna el valor 1.\n# Los parámetros que tienen asignados un valor no pueden llevar espacios antes\n# ni después del igual.\n# Ejemplo de llamada: variable=$(f_parametro_kernel srp_copia)\n# \nfunction f_parametro_kernel () {\nVALOR_DEL_PARAMETRO=\"\" # Para guardar el valor del parámetro\nRESULTADO_FUNCION=1    # Resultado de la función:\n                       #         0=Se obtuvo el valor del parámetro\n                       #         1=No se pudo obtener el valor u otro error\nif [ ! -z $1 ] ; then\n   for i in `cat /proc/cmdline` ; do\n      case \"${1}\" in\n         # ${i/=*/} se queda con la parte antes del igual\n         # ${i/*=/} se queda con la parte después del igual\n         # Si el parametro \"i\" no tiene \"=\" se queda como está.\n\n         \"${i/=*/}\" )\n                RESULTADO_FUNCION=0 # Se encontró el parámetro\n\t        # Si es un parámetro con \"=\"\n\t        if [ -z ${i/*=*/} ] ; then\n\t           VALOR_DEL_PARAMETRO=\"${i/*=/}\"\n                   if [ ! -z $VALOR_DEL_PARAMETRO ] ; then\n                      echo \"$VALOR_DEL_PARAMETRO\"\n\t\t   else\n                      RESULTADO_FUNCION=1 # El parámetro no tiene valor\n                   fi\n\t\tfi\n\t        break ;;\n      esac\n   done\nfi\nreturn $RESULTADO_FUNCION\n}\n\n################################################################################\n# Función que devuelve el directorio de la copia con la que se va a trabajar.\n# Si no se pasó ninguno reinicia el sistema.\n# Necesita mínimo un parámetro de entrada para guardar el nombre de la copia.\n# Admite otro segundo parámetro para crear dicho directorio si no existe.\n# Ejemplos de llamada: f_dir_copia COPIA\n#                      f_dir_copia COPIA crea\n\nfunction f_dir_copia () {\n\nlocal variable=$1 # Guarda el nombre de la variable que se pasa como parametro.\n\n# Se obtiene el nombre del directorio del backup\nlocal dir=$(f_parametro_kernel srp_copia)\n\n# Si no se obtuvo un nombre se reinicia el sistema\nif [ -z $dir ] ; then\n   echo \"ERROR: No se ha obtenido un nombre para el directorio del backup\"\n   echo \"       con el que se quiere trabajar.\"\n   echo \"       Estos son los parámetros que se pasaron al kernel:\"\n   cat /proc/cmdline\n   echo \"Compruebe que existe el parámetro \\\"srp_copia=\\\" seguido del nombre\"\n   echo \"de la copia sin ningún espacio.\"\n   proceso_terminado 1 60\n   exit 1\nfi\n\necho \"Copia seleccionada: $dir\"\n\nif [ \"x$2\" = \"xcrea\" ] ; then\n   if [ ! -d \"$BACKUP_MNT/$dir\" ] ; then\n      echo \"Creando el directorio para el backup: $BACKUP_MNT/$dir\"\n      mkdir \"$BACKUP_MNT/$dir\"\n   fi\nfi\neval $variable=$dir\n}\n\n################################################################################\n# Muestra un mensaje de proceso terminado durante un tiempo y reinicia.\n# La función acepta uno o dos parámetros. Cuando se pasa un sólo parámetro este\n# es tomado como un código de estado o error y la duración del mensaje que se\n# muestra es de 30 segundos.\n# Cuando se pasan dos parámetros el primero significa lo mismo y el segundo el\n# tiempo que se quiere esperar en la pausa del mensaje.\n\nfunction proceso_terminado () {\nif [ ! -z $1 ] ; then\n   case $1 in\n      \"0\") beep -f 600 -l 1000 -n -f 700 -l 1000 -n -f 800 -l 1000 -n -f 900 -l 1000 ;;\n        *) for i in 1 2 3 4; do\n\t      beep -f 1400 -l 400 -n -f 1100 -l 400\n\t   done\n\t   ;;\n   esac     \nfi\nif [ -z $2 ] ; then\n   tiempo=30\nelse\n   tiempo=$2\nfi\necho \necho \"################################################################################\"\necho \"                       P R O C E S O  T E R M I N A D O                         \"\necho \"           El sistema se reiniciará en $tiempo seg. o cuando pulse ENTER...\"\necho \"################################################################################\"\nread -t $tiempo\nreboot\n}\n################################################################################\n# Función que emite un pitido cada 10 segundos. Se ejecuta en segundo plano\n# creando otro proceso aparte por lo que hay que pasarle como parámetro\n# el nombre de una variable donde guardará el PID de ese proceso para poder\n# matarlo cuando queramos. Ejemplo de llamada: estoy_vivo pidsonido\nfunction estoy_vivo () {\nif [ ! -z $1 ] ; then\n   local variable=$1\n   (while : ; do\n      beep -f 800 -l 60 -n -f 1000 -l 100\n      sleep 10\n   done) &\n   local pid=$!\n   eval $variable=$pid\nelse\n   echo \"ERROR: función estoy_vivo necesita un nombre de variable como parámetro.\"\nfi\n}\n"
    }
  ];