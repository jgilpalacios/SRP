<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de Particiones</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px;
            cursor: pointer;
            border: 1px solid black;
        }

        .active {
            background-color: lightgray;
            border-width: 3px;
        }

        .menu {
            display: none;
            border: 1px solid black;
            padding: 10px;
        }

        .visible {
            display: block;
        }

        /*carga de configuracion */
        .card {
            border: 1px solid #e5e7eb;
            padding: 1rem 1.25rem;
            border-radius: 8px;
            max-width: 720px;
        }

        button {
            /*padding: .5rem .75rem;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            background: white;*/
            cursor: pointer;
        }

        pre {
            white-space: pre-wrap;
            background: #f8fafc;
            padding: .75rem;
            border-radius: 6px;
            overflow-x: auto;
        }

        .ok {
            color: #065f46;
        }

        .err {
            color: #b91c1c;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="./autorun.js"></script>
    <script src="./srp.js"></script>
</head>

<body>
    <h1>Gestor de Particiones</h1>
    <p><label for="numDiscos">Número de discos:</label>
        <select id="numDiscos" onchange="actualizarDiscos()">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
        </select>
        <!-- Botón visible que abre el input oculto -->
        <button id="selectBtn">Cargar configuración.txt</button>

        <!-- input de archivo oculto (acepta .txt). No forzará nombre, por eso verificamos en JS -->
        <input id="fileInput" type="file" accept=".txt,text/plain" style="display:none" />

        <!-- Selecciona archivo particiones.txt -->
        <label><input type="checkbox" id="chkUUID"
                title="Si se selecciona se deben cargar las UUIDs de las particiones de cada equipo a instalar el SRP" />
            Usar UUID</label>
        <span id="uuidSection" style="display:none;">
            Ejecuta en una terminal la orden: <b>blkid -s UUID>particiones.txt</b>
            <button id="selectPartBtn">Buscar particiones.txt</button>
            <input id="partFileInput" type="file" accept=".txt,text/plain" style="display:none" /></span>
    </p>

    <div class="tabs" id="tabs"></div>
    <div id="menu" class="menu"></div>
    <button onclick="comprobarErrores()">Comprobación</button><button onclick="generarZip()">Descargar SRP.ZIP</button>
    <h4>Info: <a href="https://www.educa2.madrid.org/web/jgilpalacios/srp"
            target="_blank">https://www.educa2.madrid.org/web/jgilpalacios/</a></h4>
    <h4>Info: <a href="https://jgilpalacios.neocitiess.org/SRP/info/"
            target="_blank">https://jgilpalacios.neocitiess.org/SRP/info/</a></h4>
    <p id="error"></p>
    <!--Parseador-->
    <span id="cargarConfResultado" style="visibility: hidden;">
        <p>Estado: <span id="status">No hay archivo seleccionado</span></p>
        <p>Nombre del archivo: <strong id="fileName">—</strong></p>

        <h3>Contenido (si se pudo leer)</h3>
        <pre id="fileContent">—</pre>
    </span>
    <script>
        let seHaCargadoUUIDsFile = false;
        let configuracion = {
            users: [{ nombre: 'madrid', pass: 'cmadrid', enc: false }, { nombre: 'consejeria', pass: 'cconsejeria', enc: true }],
            nDiscos: 1,
            particiones: [
                { nombre: 'EFI', particionEFI: { disco: 'a', particion: 1, activa: true } },
                { nombre: 'SRP', particionSRP: { disco: 'a', particion: 7, activa: true }, particionSRPBACKUP: { disco: 'a', particion: 8, activa: true } },
                { nombre: 'WINDOWS', particionWIN: { disco: 'a', particion: 3, activa: true }, particionRES: { disco: 'a', particion: 4, activa: true }, particionRES2: { disco: 'a', particion: 4, activa: false } },
                { nombre: 'MAX', particionMAX: { disco: 'a', particion: 5, activa: true }, particionSWAP: { disco: 'a', particion: 6, activa: true } }
            ]
        };
        //////////
        let configuraciónContenido = null; // contiene el texto del archivo (string)

        const selectBtn = document.getElementById('selectBtn');
        const fileInput = document.getElementById('fileInput');
        const statusEl = document.getElementById('status');
        const fileNameEl = document.getElementById('fileName');
        const fileContentEl = document.getElementById('fileContent');

        // Abrir diálogo de archivos al pulsar el botón
        selectBtn.addEventListener('click', () => fileInput.click());

        // Manejar la selección de archivo
        fileInput.addEventListener('change', async (event) => {
            document.getElementById('cargarConfResultado').style.visibility = 'visible';
            const file = fileInput.files[0];
            if (!file) return; // usuario canceló

            // Comprobamos el nombre exacto solicitado
            // Nota: aquí se comprueba exactamente 'configuración.txt' (con tilde).
            // Si quieres aceptar también 'configuracion.txt' sin tilde, añade esa condición.
            const expectedName = 'configuración.txt';
            if (file.name !== expectedName) {
                alert('El archivo debe llamarse ' + expectedName);
                statusEl.textContent = 'Archivo incorrecto: se esperaba "' + expectedName + '" no "' + file.name + '".';
                statusEl.className = 'err';
                fileNameEl.textContent = file.name;
                fileContentEl.textContent = 'El archivo seleccionado no se llama "' + expectedName + '".';
                // Limpiamos la selección para permitir volver a elegir el mismo archivo si se desea
                fileInput.value = '';
                configuración = null;
                configuraciónContenido = null;
                return;
            }

            // Si llegamos aquí, el nombre coincide -> asignamos a la variable 'configuración'
            configuración = file; // objeto File de la API File
            statusEl.textContent = 'Archivo válido seleccionado';
            statusEl.className = 'ok';
            fileNameEl.textContent = file.name;

            try {
                // Leer contenido como texto (File.text() devuelve una Promise)
                configuraciónContenido = await file.text();
                fileContentEl.textContent = configuraciónContenido;
                procesarConfiguración(configuraciónContenido)
            } catch (err) {
                fileContentEl.textContent = 'Error leyendo el archivo: ' + err;
            }
            // Aquí puedes usar la variable 'configuración' y 'configuraciónContenido' en tu código
            // por ejemplo: procesarConfiguración(configuraciónContenido);
        });

        // Ejemplo de función que podría usar la configuración ya leída
        function procesarConfiguración(texto) {

            // parsear, dividir por líneas, JSON.parse, etc. según formato de tu archivo
            configuracion = JSON.parse(texto);
            cargarTabs();
            console.log('Procesando configuración:', texto);
        }
        ////Asignamos las UUID de las particiones desde el archivo particiones.txt
        const selectPartBtn = document.getElementById('selectPartBtn');
        const partFileInput = document.getElementById('partFileInput');

        let particionesContenido = null;

        // Mostrar/ocultar botón según checkbox
        const chkUUID = document.getElementById('chkUUID');
        chkUUID.addEventListener('change', () => {
            configuracion.usarUUID = chkUUID.checked;
            selectPartBtn.style.display = chkUUID.checked ? 'inline-block' : 'none';
            document.getElementById('uuidSection').style.display = chkUUID.checked ? 'inline' : 'none';
        });

        selectPartBtn.addEventListener('click', () => partFileInput.click());

        partFileInput.addEventListener('change', async () => {
            const file = partFileInput.files[0];
            if (!file) return;
            document.getElementById('cargarConfResultado').style.visibility = 'visible';
            // Comprobamos el nombre exacto solicitado
            const expectedName = 'particiones.txt';
            if (file.name !== expectedName) {
                alert('El archivo debe llamarse ' + expectedName);
                statusEl.textContent = 'Archivo incorrecto: se esperaba "' + expectedName + '" no "' + file.name + '".';
                statusEl.className = 'err';
                fileNameEl.textContent = file.name;
                fileContentEl.textContent = 'El archivo seleccionado no se llama "' + expectedName + '".';
                // Limpiamos la selección para permitir volver a elegir el mismo archivo si se desea
                //fileInput.value = '';
                partFileInput.value = '';



                return;
            }
            statusEl.textContent = 'Archivo válido seleccionado';
            statusEl.className = 'ok';
            fileNameEl.textContent = file.name;

            try {
                // Leer contenido como texto (File.text() devuelve una Promise)
                particionesContenido = await file.text();
                fileContentEl.textContent = particionesContenido;
                asignarUUIDs();
            } catch (err) {
                fileContentEl.textContent = 'Error leyendo el archivo: ' + err;
            }

            //particionesContenido = await file.text();

            //asignarUUIDs();
        });

        function asignarUUIDs() {
            /*if (!configuraciónContenido) {
              alert('Primero carga configuración.txt');
              return;
            }*/
            if (!particionesContenido) {
                alert('Primero carga particiones.txt');
                return;
            }

            let conf;
            try {
                //conf = JSON.parse(configuraciónContenido);
                conf = configuracion;
            } catch (e) {
                alert('Error al parsear configuración: ' + e);
                return;
            }

            const lineas = particionesContenido.split("\n").filter(l => l.trim() !== "");
            const mapaUUID = {};
            const arrUUID = [];
            for (const l of lineas) {
                const partes = l.split(':');
                if (partes.length >= 2) {
                    const dev = partes[0].trim();
                    const uuid = partes[1].trim();
                    mapaUUID[dev] = uuid;
                    arrUUID.push(uuid);
                }
            }
            let error = false
            arrUUID.forEach((uuid, index) => {
                for (let j = 0; j < index; j++) {
                    if (arrUUID[j] === uuid) {
                        alert('Atención: La UUID ' + uuid + ' está duplicada en el archivo particiones.txt');
                        error = true;
                        return;
                    }
                }
            });
            if (error) return;

            for (const part of conf.particiones) {
                for (const key of Object.keys(part)) {
                    if (key.startsWith('particion')) {
                        const p = part[key];
                        p.UUID = null; // resetear antes
                        if (p.activa) {
                            const nombreDev = `/dev/sd${p.disco}${p.particion}`;
                            if (mapaUUID[nombreDev]) {
                                p.UUID = mapaUUID[nombreDev].split('"')[1];
                            } else {
                                p.UUID = null;
                            }
                        }
                    }
                }
            }
            cargarTabs();
            seHaCargadoUUIDsFile = true;
            console.log('Configuración actualizada:', conf);

        }
        /////////

        function actualizarDiscos() {
            let numDiscos = document.getElementById("numDiscos").value;
            configuracion.nDiscos = numDiscos;
            cargarTabs();
        }
        //para gestionar las contraseñas en srp
        let srp_tab;
        function cargarTabs() {
            const tabs = document.getElementById("tabs");
            tabs.innerHTML = "";
            let srp_index = 1;

            if (configuracion.usarUUID) {
                document.getElementById('chkUUID').checked = true;
                document.getElementById('uuidSection').style.display = 'inline';
                selectPartBtn.style.display = 'inline-block';
            } else {
                document.getElementById('chkUUID').checked = false;
                document.getElementById('uuidSection').style.display = 'none';
                selectPartBtn.style.display = 'none';
            }

            configuracion.particiones.forEach((particion, index) => {
                let tab = document.createElement("div");
                tab.className = "tab";
                tab.id = particion.nombre + '_tab';
                tab.innerText = particion.nombre;
                tab.style.backgroundColor = `hsl(${index * 60}, 70%, 80%)`;
                tab.onclick = () => mostrarMenu(index, tab);
                tabs.appendChild(tab);
                if (index === srp_index) srp_tab = tab;
                const menu = document.getElementById("menu");
                menu.innerHTML = "";
                document.getElementById("error").innerText = '';
            });
            //se pone para activar srp y inicializar todo
            mostrarMenu(srp_index, srp_tab)
        }
        //para gestionar las contraseñas en srp se crean como variables globales
        let contrasenna = document.createElement("input");
        contrasenna.type = 'password';
        contrasenna.value = configuracion.users[0].pass;
        contrasenna.title = 'Utilize sólo letras y números para la contraseña,\nLas letras acentuadas y la letra ñ no son válidas.';
        contrasenna.onmouseover = () => { contrasenna.type = 'text' }
        contrasenna.onmouseout = () => { contrasenna.type = 'password' }
        contrasenna.onchange = () => {
            if (validarTexto(contrasenna.value)) configuracion.users[0].pass = contrasenna.value;
            else {
                alert('Utilize sólo letras y números para la contraseña,\nLas letras acentuadas y la letra ñ no son válidas.');
                contrasenna.value = configuracion.users[0].pass;
            }
        }

        let ccontrasenna = document.createElement("input");
        ccontrasenna.id = 'password';
        ccontrasenna.type = 'password';
        ccontrasenna.value = configuracion.users[1].pass;
        setTimeout(generatePBKDF2, 1);//lanzamos en paralelo la encriptacion
        ccontrasenna.title = 'Utilize sólo letras y números para la contraseña,\nLas letras acentuadas y la letra ñ no son válidas.';
        ccontrasenna.onmouseover = () => { ccontrasenna.type = 'text' }
        ccontrasenna.onmouseout = () => { ccontrasenna.type = 'password' }
        ccontrasenna.onchange = () => {
            estaEncriptada = false;
            document.getElementById('hashedPassword').style.visibility = 'hidden';
            if (validarTexto(ccontrasenna.value)) {
                configuracion.users[1].pass = ccontrasenna.value;
                setTimeout(generatePBKDF2, 1);//lanzamos en paralelo la encriptacion
            } else {
                alert('Utilize sólo letras y números para la contraseña,\nLas letras acentuadas y la letra ñ no son válidas.');
                ccontrasenna.value = configuracion.users[1].pass;
            }
        }

        let hashedPassword = document.createElement("input");
        hashedPassword.type = 'text';
        hashedPassword.id = 'hashedPassword';
        hashedPassword.title = 'Haz doble click para copiar en el portapapeles la contraseña encriptada';
        hashedPassword.ondblclick = () => {
            hashedPassword.select(); // Selecciona el texto
            document.execCommand("copy"); // Copia el texto al portapapeles
        }
        hashedPassword.style.visibility = 'hidden';

        function mostrarMenu(index, tab) {
            const menu = document.getElementById("menu");
            menu.innerHTML = "";
            menu.style.backgroundColor = tab.style.backgroundColor;
            let particion = configuracion.particiones[index];

            document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
            tab.classList.add("active");
            //if(contenidoTab[index]===undefined){
            Object.keys(particion).forEach(clave => {
                if (clave !== "nombre") {
                    let div = document.createElement("div");
                    let label = document.createElement("label");
                    label.innerText = clave + ": ";
                    let select = document.createElement("select");

                    for (let i = 1; i <= 9; i++) {
                        let option = document.createElement("option");
                        option.value = i;
                        option.innerText = i;
                        if (particion[clave].particion === i) option.selected = true;
                        select.appendChild(option);
                    }

                    let discoSelect = document.createElement("select");
                    let discos = ['a', 'b', 'c', 'd'].slice(0, configuracion.nDiscos);
                    discos.forEach(disco => {
                        let option = document.createElement("option");
                        option.value = disco;
                        option.innerText = "sd" + disco;
                        if (particion.nombre === "EFI" && disco !== "a") return;
                        if (particion[clave].disco === disco) option.selected = true;
                        discoSelect.appendChild(option);
                    });

                    discoSelect.onchange = () => {
                        particion[clave].disco = discoSelect.value;
                        document.getElementById("error").innerText = '';
                        //if(configuracion.usarUUID) alert('Si ha cambiado el disco y está usando UUIDs, debe volver a cargar el archivo particiones.txt para actualizar las UUIDs asignadas.');
                        particion[clave].UUID = null;
                        label2.innerText = particion[clave].UUID ? ' UUID: ' + particion[clave].UUID : ' UUID: (no asignada)';
                        //actualizarDiscos();
                    };

                    let checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.checked = particion[clave].activa;

                    select.onchange = () => {
                        particion[clave].particion = parseInt(select.value);
                        document.getElementById("error").innerText = '';
                        //if(configuracion.usarUUID) alert('Si ha cambiado la partición y está usando UUIDs, debe volver a cargar el archivo particiones.txt para actualizar las UUIDs asignadas.');
                        particion[clave].UUID = null;
                        label2.innerText = particion[clave].UUID ? ' UUID: ' + particion[clave].UUID : ' UUID: (no asignada)';
                    }
                    checkbox.onchange = () => {                        
                        particion[clave].activa = checkbox.checked;
                        if(clave==='particionWIN'&&!particion[clave].activa){
                            //si desactiva windows desactiva las particiones de recuperación
                            particion['particionRES'].activa=false;
                            particion['particionRES2'].activa=false;
                            document.getElementById(particion.nombre + '_tab').click();// = particion.nombre + '_tab';
                        }
                        if(clave==='particionMAX'&&!particion[clave].activa){
                            //si desactiva MAX desactiva la particion swap
                            particion['particionSWAP'].activa=false;
                            document.getElementById(particion.nombre + '_tab').click();
                         
                        }
                        document.getElementById("error").innerText = '';
                    }

                    div.appendChild(label);
                    div.appendChild(discoSelect);
                    div.appendChild(select);
                    if (/*clave !== 'particionEFI' && clave !== 'particionSRPBACKUP' &&*/ clave !== 'particionSRP') div.appendChild(checkbox);
                    let label2 = document.createElement("label");
                    label2.innerText = particion[clave].UUID ? ' UUID: ' + particion[clave].UUID : ' UUID: (no asignada)';
                    div.appendChild(label2);

                    if (clave === 'particionSRPBACKUP') {
                        let label = document.createElement("label");
                        label.innerText = 'user: madrid => clave: ';
                        let parrafo = document.createElement("p");

                        parrafo.appendChild(label);
                        parrafo.appendChild(contrasenna);
                        div.appendChild(parrafo);
                        label = document.createElement("label");
                        label.innerText = 'superuser: consejeria => clave: ';
                        parrafo = document.createElement("p");

                        parrafo.appendChild(label);
                        parrafo.appendChild(ccontrasenna);
                        label = document.createElement("label");
                        label.innerText = ' Encriptado grub.pbkdf2: ';

                        parrafo.appendChild(label);
                        parrafo.appendChild(hashedPassword);
                        div.appendChild(parrafo);
                    }
                    menu.appendChild(div);
                }
                //contenidoTab[index]=menu;
            });
            //}else{menu=contenidoTab[index]}
            menu.classList.add("visible");
        }

        function comprobarErrores() {
            let recuerdaCargarUUIDs = '';
            document.getElementById("cargarConfResultado").style.visibility = 'hidden';
            if (configuracion.usarUUID && !seHaCargadoUUIDsFile) {
                let seguir = confirm('Si se va a usar UUIDs y no se ha cargado desde el archivo particiones.txt');
                if (!seguir) return false;
            }
            //se pone activa srp para tener en document las partes de las contraseña
            mostrarMenu(1, srp_tab)
            let errorMsg = "";
            let activas = new Set();
            let UUIDs = new Set();
            configuracion.particiones.forEach(particion => {
                Object.keys(particion).forEach(clave => {
                    if (clave !== "nombre") {
                        let id = particion[clave].disco + particion[clave].particion;
                        if (particion[clave].activa) {
                            if (activas.has(id)) {
                                errorMsg += `Conflicto: La partición sd${id} está duplicada.\n`;
                            }
                            activas.add(id);
                            if (configuracion.usarUUID) {
                                if (!particion[clave].UUID) {
                                    recuerdaCargarUUIDs = '\nRecuerda cargar las UUIDs desde el archivo particiones.txt si has cambiado alguna partición o disco.\n';
                                    errorMsg += `Error: La partición sd${id} no tiene UUID asignada.\n`;
                                } else {
                                    if (UUIDs.has(particion[clave].UUID)) {
                                        errorMsg += `Conflicto: La UUID ${particion[clave].UUID} está duplicada.\n`;
                                    }
                                    UUIDs.add(particion[clave].UUID);
                                }
                            }
                        }
                    }
                });
            });

            let efi = configuracion.particiones.find(p => p.nombre === "EFI");
            if (efi && efi.particionEFI.disco !== 'a') {
                errorMsg += "Error: La partición EFI debe estar en el disco 'a'.\n";
            }
            if (!estaEncriptada) generatePBKDF2();//solo si no se ha encriptado previamente se lanza
            //comprobamos que si usammos windows legacy esta activada la primera particion de recuperacion
            let pWin = configuracion.particiones[2].particionWIN;
            let pResW = configuracion.particiones[2].particionRES;
            let pEFI = configuracion.particiones[0].particionEFI;
            let pMAX = configuracion.particiones[3].particionMAX;
            let pSWAP = configuracion.particiones[3].particionSWAP;
            if (!pEFI.activa && pWin.activa && !pResW.activa) {
                errorMsg += 'Error: En arranque legacy es la primera particion reservada para el sistiema la que windows utiliza para arrancar.\n\tDebe por tanto estar seleccionada.\n';

            }
            if (!pWin.activa && !pMAX.activa) {
                errorMsg += 'Error: Debe estar activa al menos una partición de Windows o MAX.\n';
            }
            if (!pMAX.activa && pSWAP.activa) {
                errorMsg += 'Error: No puede estar activa la partición SWAP si no lo está la partición MAX.\n';

            }
            if (pResW.activa) {
                if (!pWin.activa) {
                    errorMsg += 'Error: La particion de recuperación de windows no puede estar activa si la particion de windows no lo está.\n';
                }
            }
            let pResW2 = configuracion.particiones[2].particionRES2;
            if (pResW2.activa) {
                if (!pWin.activa) {
                    errorMsg += 'Error: La segunda particion de recuperación de windows no puede estar activa si la particion de windows no lo está.\n';
                }
                if (!pResW.activa) {
                    errorMsg += 'Error: La segunda particion de recuperación de windows no puede estar activa si la primera no lo está.\n';
                }
            }
            if(pWin.activa && !pResW.activa){
                errorMsg += 'Error: Windows tiene siempre la primera particion de recuperación activa.\n';
            }
            //alert(!pEFI.activa&&pWin.activa&&!pResW.activa+'****')
            //alert(errorMsg || "Configuración válida.\n" + JSON.stringify(configuracion));
            errorMsg = recuerdaCargarUUIDs + errorMsg;
            document.getElementById("error").innerText = errorMsg || "Configuración válida.\n" + JSON.stringify(configuracion);
            return errorMsg === '';
        }

        cargarTabs();

        function cargarImagenes(zip) {
            return new Promise((resolve, reject) => {
                const folder = zip.folder("srp/fondos");
                const imageFiles = ["fondo.png", "fondo2.png", "fondo2.png", "fondo3.png", "fondogene.png", "fondorest.png", "fondoesp.png"]; // Nombres de imágenes esperados
                let loadedImages = 0;

                imageFiles.forEach(imgName => {
                    fetch(`fondos/${imgName}`)
                        .then(response => response.blob())
                        .then(blob => {
                            const reader = new FileReader();
                            reader.onload = function () {
                                folder.file(imgName, reader.result.split(",")[1], { base64: true });
                                loadedImages++;
                                if (loadedImages === imageFiles.length) resolve();
                            };
                            reader.readAsDataURL(blob);
                        })
                        .catch(() => {
                            loadedImages++;
                            if (loadedImages === imageFiles.length) resolve();
                        });
                });
            });
        }

        function generarZip() {
            if (!comprobarErrores()) {//si hay errores se avisa y no generamos srp.zip
                alert('Revisa los errores encontrados en la configuración');
                return;
            }
            let zip = new JSZip();
            // en folder incluiremos los scripts de autorun que la base está en la variable autorun que se carga de autorun.js
            let folder = zip.folder("autorun");
            let ddiscos = ['a', 'b', 'c', 'd'];
            let pWin = configuracion.particiones[2].particionWIN;
            let pResW = configuracion.particiones[2].particionRES;
            let pResW2 = configuracion.particiones[2].particionRES2;
            let pMAX = configuracion.particiones[3].particionMAX;
            let pSWAP = configuracion.particiones[3].particionSWAP;
            let pEFI = configuracion.particiones[0].particionEFI;
            let textoSWAP = 'no_hay_swap';
            if (pSWAP.activa) textoSWAP = '/dev/sd' + pSWAP.disco + pSWAP.particion;
            let pSRP = configuracion.particiones[1].particionSRP;
            //Solo SRP sin SRPBACKUP se gestiona en srp.js con la etiqueta ##tcopytoram## que se sustituye por copytoram o nada
            //la variable tcopytoram, y montando la particion SRP en mnt/SRP y mnt/SRPBACKUP, en autorun.js no se precisan cambios.
            //el arranque de system rescue cd se hace en menuavanzado y la generacion de BackUpas con la opcion "copytoram" para que 
            // SRP sea escribible, no es necesario que lo sea en las restauraciones.
            let pSRPBACKUP = configuracion.particiones[1].particionSRPBACKUP.activa? configuracion.particiones[1].particionSRPBACKUP:configuracion.particiones[1].particionSRP;
            let tcopytoram = configuracion.particiones[1].particionSRPBACKUP.activa?'':'copytoram ';
            ///
            let ngrupos = 0;
            [pWin, pMAX, pSWAP].forEach(grupo => {
                if (grupo.activa) ngrupos++;
            });
            ngWin = 1;//al menos estaría la de windows si se llega a crear
            if (pResW.activa) ngWin++;
            if (pResW2.activa) ngWin++;
            //para máx se deja fijo 2 ya que aunque no haya swap se gestiona con no_hay_swap en el device
            //para efi dejamos fijo 1
            autorun.forEach(archivo => {
                if (archivo.nombre === 'autorun0') {
                    //El archivo autorun0 se hace todo desde aquí no se usa la plantilla de autorun.js     
                    let aux = `# version: SRP v2.0 #\n\n# Nombre de la particion que contiene los backups y los menus de GRUB;
BACKUP_DEV="/dev/sd${pSRPBACKUP.disco + pSRPBACKUP.particion}"
# SRP_DEV Particion que contiene el sofware de Sytem Rescue CD, que ejercuta los procesos
SRP_DEV="/dev/sd${pSRP.disco + pSRP.particion}"
# Punto de montaje de la partición que contendrá los backups
BACKUP_MNT="/mnt/SRPBACKUP"
# Verificar si el directorio /mnt/backup existe
if [ -d "$BACKUP_MNT" ]; then
    echo "El directorio '$BACKUP_MNT' ya existe."
else
    echo "El directorio '$BACKUP_MNT' no existe. Creándolo ahora..."
    mkdir -p "$BACKUP_MNT" # Crea el directorio (incluyendo directorios padres si no existen)
    if [ $? -eq 0 ]; then
        echo "Directorio creado exitosamente."
    else
        echo "Hubo un error al crear el directorio."
    fi
fi
# Número de grupos de particiones
NG=${ngrupos}
###############################################################################
# Número de particiones que tiene el grupo x
#Gx_NP=n
# Etiqueta del grupo. Esta etiqueta se mostrará en los menus, en mensajes tipo:
# Restaurar <ETIQUETA>...
# Generar backup de <ETIQUETA>...
#Gx_MENU="Linux"
#------------------------------------------------------------------------------
# Nombre dispositivo
#GxPn_DEV="/dev/sda1"
# Etiqueta que se muestra en los menus
#GxPn_MENU="MAX"
# Etiqueta del sistema de ficheros
#GxPn_LABEL="MAX65"
# Sistema de ficheros
#GxPn_FS="ntfs"
###############################################################################\n`;

                    if (pWin.activa) {
                        aux += `G1_NP=${ngWin}
G1_MENU="Windows"\n`;
                        if (pResW.activa) {
                            aux += `#------------------------------------------------------------------------------
G1P1_DEV="/dev/sd${pResW.disco + pResW.particion}"
G1P1_LABEL_MENU=""
G1P1_LABEL="Reservado para el sistema"
G1P1_FS="ntfs"\n`;
                        }
                        aux += `#------------------------------------------------------------------------------
G1P2_DEV="/dev/sd${pWin.disco + pWin.particion}"
G1P2_LABEL_MENU="Windows"
G1P2_LABEL="Windows"
G1P2_FS="ntfs"\n`;
                        if (pResW2.activa) {
                            aux += `#------------------------------------------------------------------------------
G1P3_DEV="/dev/sd${pResW2.disco + pResW2.particion}"
G1P3_MENU=""
G1P3_LABEL="Reservado para el sistema 2"
G1P3_FS="ntfs"\n`;
                        }
                        aux += `###############################################################################\n`;
                    }
                    if (pMAX.activa) {
                        aux += `G2_NP=2
G2_MENU="MAX"
#------------------------------------------------------------------------------
G2P1_DEV="/dev/sd${pMAX.disco + pMAX.particion}"
G2P1_LABEL_MENU="MAX"
G2P1_LABEL="MAX12"
G2P1_FS="ext4"
#------------------------------------------------------------------------------
# Asignar a G2P2_DEV la etiqueta "no_hay_swap" para indicar que no existe swap.
G2P2_DEV="${textoSWAP}"
G2P2_LABEL_MENU=""
G2P2_LABEL="swap"
G2P2_FS="swap"
###############################################################################\n`;
                    }
                    aux += `#--No usamos la particion datos.
#G3_NP=1
#G3_MENU="Datos"
#------------------------------------------------------------------------------
#G3P1_DEV="/dev/sda5"
#G3P1_LABEL_MENU="Datos"
#G3P1_LABEL="Datos"
#G3P1_FS="ntfs"
###############################################################################
${pEFI.activa ? '' : '#'}G4_NP=1
${pEFI.activa ? '' : '#'}G4_MENU="EFI"
#------------------------------------------------------------------------------
${pEFI.activa ? '' : '#'}G4P1_DEV="/dev/sd${pEFI.disco + pEFI.particion}"
${pEFI.activa ? '' : '#'}G4P1_LABEL_MENU="EFI"
${pEFI.activa ? '' : '#'}G4P1_LABEL="EFI"
${pEFI.activa ? '' : '#'}G4P1_FS="fat32"
###############################################################################              
`;
                    folder.file(archivo.nombre, aux);
                } else {
                    if (['autorun1', 'autorun2', 'autorun3', 'autorun8', 'funciones.sh'].includes(archivo.nombre)) {
                        folder.file(archivo.nombre, archivo.contenido);
                    } else {
                        if (['autorun4', 'autorun6'].includes(archivo.nombre) && pWin.activa) {
                            texto = archivo.contenido;
                            if (!pResW.activa) {
                                texto = reemplazarTexto(texto, 'particion recuperacion windows', '');
                            }
                            if (!pResW2.activa) {
                                texto = reemplazarTexto(texto, 'segunda particion recuperacion windows', '');
                                if (['autorun4'].includes(archivo.nombre)) texto = reemplazarTexto(texto, '2 segunda particion recuperacion windows', '');

                            }

                            folder.file(archivo.nombre, texto);
                        }
                        if (['autorun5', 'autorun7'].includes(archivo.nombre) && pMAX.activa) {
                            folder.file(archivo.nombre, archivo.contenido);
                        }
                        if (['autorun9', 'autorunA'].includes(archivo.nombre) && pEFI.activa) {
                            folder.file(archivo.nombre, archivo.contenido);
                        }
                        if (['autorunB'].includes(archivo.nombre)) {
                            texto = archivo.contenido;
                            if (!pWin.activa) {
                                texto = reemplazarTexto(texto, 'entrada windows', '');
                            }
                            if (!pMAX.activa) {
                                texto = reemplazarTexto(texto, 'entrada MAX', '');
                            }
                            if (!pEFI.activa) {
                                texto = reemplazarTexto(texto, 'entrada EFI', '');
                            }
                            folder.file(archivo.nombre, texto);
                        }
                    }
                }
            });
            ///creamos el configurador de grub en su sitio que enlaza con el menuprincipal de SRP
            let folderboot = zip.folder("boot/grub");
            folderboot.file('grub.cfg', 'configfile /srp/menus/menuprincipal.cfg');

            //creamos los menúns de SRP en el arranque con grub EFI la base esta en los variable menus que proviene de srp.js
            let folder2 = zip.folder("srp/menus");

            menus.forEach(archivo => {
                //alert('procesando ' + archivo.nombre);
                let texto = archivo.contenido;
                if (archivo.nombre === 'menuprincipal.cfg') { //alert('siii'

                    let aux = `set pSRP=(hd${numDisco(pSRP.disco)},${pSRP.particion})  # Definir la variable
export pSRP       # Hacerla global
${pEFI.activa ? '' : '#'}set pEFI=(hd${numDisco(pEFI.disco)},${pEFI.particion})  
${pEFI.activa ? '' : '#'}export pEFI   
#set pWIN=(hd0,3)  
#export pWIN
set pMAX=(hd${numDisco(pMAX.disco)},${pMAX.particion})  
export pMAX

set superusers="consejeria"
export superusers
password_pbkdf2 consejeria ${document.getElementById('hashedPassword').value}
password madrid ${configuracion.users[0].pass}
`;
                    let legacyWIN = `menuentry "Iniciar Windows" --unrestricted {
set root=(hd${numDisco(pResW.disco)},${pResW.particion})
chainloader +1
}`;

                    let legacyMAX = `menuentry "Iniciar MAX" --unrestricted {
set root=(hd${numDisco(pMAX.disco)},${pMAX.particion})
chainloader +1
}`;
                    //si esta activa usar UUID las cambiamos por:
                    if (configuracion.usarUUID) {
                        legacyWIN = `menuentry "Iniciar Windows" --unrestricted {
set root=(hd${numDisco(pResW.disco)},${pResW.particion})
if [ x$feature_platform_search_hint = xy ]; then
  search --no-floppy --fs-uuid --set=root --hint-bios=hd${numDisco(pResW.disco)},gpt${pResW.particion} --hint-efi=hd${numDisco(pResW.disco)},gpt${pResW.particion} --hint-baremetal=ahci${numDisco(pResW.disco)},gpt${pResW.particion}  ${pResW.UUID}
else
  search --no-floppy --fs-uuid --set=root ${pResW.UUID}
fi
chainloader +1
}`;
                        legacyMAX = `menuentry "Iniciar MAX" --unrestricted {
set root=(hd${numDisco(pMAX.disco)},${pMAX.particion})
if [ x$feature_platform_search_hint = xy ]; then
  search --no-floppy --fs-uuid --set=root --hint-bios=hd${numDisco(pMAX.disco)},gpt${pMAX.particion} --hint-efi=hd${numDisco(pMAX.disco)},gpt${pMAX.particion} --hint-baremetal=ahci${numDisco(pMAX.disco)},gpt${pMAX.particion}  ${pMAX.UUID}
else
  search --no-floppy --fs-uuid --set=root ${pMAX.UUID}
fi
chainloader +1
}`;
                    }
                    let auxEFI = `if [ x$feature_platform_search_hint = xy ]; then
  search --no-floppy --fs-uuid --set=root --hint-bios=hd${numDisco(pEFI.disco)},gpt${pEFI.particion} --hint-efi=hd${numDisco(pEFI.disco)},gpt${pEFI.particion} --hint-baremetal=ahci${numDisco(pEFI.disco)},gpt${pEFI.particion}  ${pEFI.UUID}
else
  search --no-floppy --fs-uuid --set=root ${pEFI.UUID}
fi`;
                    let UEFI_WIN = `menuentry "Iniciar Windows" --unrestricted --class windows --class os {
insmod part_gpt
insmod fat
set root=$pEFI
${auxEFI}
chainloader /EFI/Microsoft/Boot/bootmgfw.efi
}`;
                    let UEFI_MAX = `menuentry "Iniciar MAX" --unrestricted --class max --class gnu-linux --class gnu --class os {
insmod part_gpt
insmod fat
set root=$pEFI
${auxEFI}
chainloader /EFI/ubuntu/grubx64.efi
}`;

                    texto = reemplazarTexto(texto, 'variables globales grub', aux)
                    if (!pEFI.activa) {
                        texto = reemplazarTexto(texto, 'entrada windows', legacyWIN)
                        texto = reemplazarTexto(texto, 'entrada MAX', legacyMAX)
                    } else if (configuracion.usarUUID) {
                        texto = reemplazarTexto(texto, 'entrada windows', UEFI_WIN)
                        texto = reemplazarTexto(texto, 'entrada MAX', UEFI_MAX)
                    }
                    if (!pWin.activa) texto = reemplazarTexto(texto, 'entrada windows', '')
                    if (!pMAX.activa) texto = reemplazarTexto(texto, 'entrada MAX', '')
                }
                if (archivo.nombre === 'menucopia1.cfg') {
                    if (!pWin.activa) texto = reemplazarTexto(texto, 'entrada windows', '')
                    if (!pMAX.activa) texto = reemplazarTexto(texto, 'entrada MAX', '')
                    if (!pMAX.activa || !pWin.activa) texto = reemplazarTexto(texto, 'entrada windows y MAX', '')
                    if (!pEFI.activa) texto = reemplazarTexto(texto, 'entrada EFI', '')
                }
                if (archivo.nombre === 'menucopia2.cfg') {
                    if (!pWin.activa) {
                        texto = reemplazarTexto(texto, 'entrada windows', '');
                        texto = reemplazarTexto(texto, 'entrada windows2', '');
                        //alert(texto+'\n'+archivo.nombre+'\n'+archivo.contenido)
                    }
                    if (!pMAX.activa) {
                        texto = reemplazarTexto(texto, 'entrada MAX', '');
                        texto = reemplazarTexto(texto, 'entrada MAX2', '');
                    }
                    if (!pMAX.activa || !pWin.activa) {
                        texto = reemplazarTexto(texto, 'entrada windows y MAX', '');
                        texto = reemplazarTexto(texto, 'entrada windows y MAX2', '');
                    }
                    if (!pEFI.activa) {
                        texto = reemplazarTexto(texto, 'entrada EFI', '');
                        texto = reemplazarTexto(texto, 'entrada EFI2', '');
                    }
                }
                if (archivo.nombre === 'menuespecial.cfg') {
                    if (!pWin.activa) {
                        texto = reemplazarTexto(texto, 'entrada windows', '');
                    }
                    if (!pMAX.activa) {
                        texto = reemplazarTexto(texto, 'entrada MAX', '');;
                    }
                }
                if (configuracion.usarUUID) {
                    if (texto.indexOf('set root=$pSRP' > -1)) {
                        let fragmentos = texto.split('set root=$pSRP')
                        let nuevoTexto = '';
                        let n = fragmentos.length - 1;
                        fragmentos.forEach((fragmento, indice) => {
                            if (indice < n) {
                                nuevoTexto += fragmento + `set root=$pSRP
if [ x$feature_platform_search_hint = xy ]; then
  search --no-floppy --fs-uuid --set=root --hint-bios=hd${numDisco(pSRP.disco)},gpt${pSRP.particion} --hint-efi=hd${numDisco(pSRP.disco)},gpt${pSRP.particion} --hint-baremetal=ahci${numDisco(pSRP.disco)},gpt${pSRP.particion}  ${pSRP.UUID}
else
  search --no-floppy --fs-uuid --set=root ${pSRP.UUID}
fi`;
                            } else {
                                nuevoTexto += fragmento;
                            }
                        });
                        texto = nuevoTexto;
                    };
                }
                //solo SRP sin SRPBACKUP se gestiona en srp.js con la etiqueta ##tcopytoram## que se sustituye por copytoram o nada
                if(['menuavanzado.cfg','menugenewin2.cfg','menugenewinmax2.cfg','menugenemax2.cfg','menugeneEFI2.cfg','menuespecial.cfg']){
                    let partes=texto.split('##tcopytoram##');
                    if(partes.length>1){
                        texto=partes.join(tcopytoram);
                    }
                }
                ///añadimos el archivo si procede
                if (['menuavanzado.cfg', 'menucopia1.cfg', 'menucopia2.cfg', 'menuprincipal.cfg', 'menuespecial.cfg'].includes(archivo.nombre)) {
                    folder2.file(archivo.nombre, texto);
                } else {
                    if (pWin.activa && ['menugenewin2.cfg', 'menurestwin1.cfg', 'menurestwin2.cfg'].includes(archivo.nombre)) {
                        folder2.file(archivo.nombre, texto);
                    }
                    if (pMAX.activa && ['menugenemax2.cfg', 'menurestmax1.cfg', 'menurestmax2.cfg'].includes(archivo.nombre)) {
                        folder2.file(archivo.nombre, texto);
                    }
                    if (pWin.activa && pMAX.activa && ['menugenewinmax2.cfg', 'menurestwinmax1.cfg', 'menurestwinmax2.cfg'].includes(archivo.nombre)) {
                        folder2.file(archivo.nombre, texto);
                    }
                    if (pEFI.activa && ['menugeneEFI2.cfg', 'menurestEFI1.cfg', 'menurestEFI2.cfg'].includes(archivo.nombre)) {
                        folder2.file(archivo.nombre, texto);
                    }
                }
            });
            /**
             * Aqui añadimos los elementos de la carpeta herramientas, no se ha usado plantilla a diferencia de autorun.js y srp.js
             */
            let folder3 = zip.folder("herramientas");

            //primero añadimos a dicha carpeta la configuración con que hemos generado menus de srp, scripts de autorun
            //y las contraseñas de madrid y consejería para uso en el futuro.
            folder3.file('configuración.txt', JSON.stringify(configuracion));


            let herramienta = `#!/bin/bash

## Crea las carpetas necesarias y monta en ella las particiones que contienen ${pEFI.activa ? 'EFI, ' : ''}SRPBACUP y SRP.

${pEFI.activa ? '' : '#'}#creamos la carpeta EFI para contener la particion EFI
${pEFI.activa ? '' : '#'}mkdir /mnt/EFI
${pEFI.activa ? '' : '#'}#montamos la particion EFI en esa carpeta
${pEFI.activa ? '' : '#'}mount /dev/sd${pEFI.disco + pEFI.particion} /mnt/EFI

#creamos la carpeta SRPBACKUP para contener la particion SRPBACKUP
mkdir /mnt/SRPBACKUP
#montamos la particion SRPBACKUP en esa carpeta
mount /dev/sd${pSRPBACKUP.disco + pSRPBACKUP.particion} /mnt/SRPBACKUP

#creamos la carpeta SRP para contener la particion SRP
mkdir /mnt/SRP
#montamos la particion SRP en esa carpeta
mount /dev/sd${pSRP.disco + pSRP.particion} /mnt/SRP`;
            folder3.file('Monta' + (pEFI.activa ? 'EFI_' : '') + 'SRPBACUP_SRP.sh', herramienta);
            herramienta = pEFI.activa ? `#!/bin/bash

# Creamos la entrada en arranque EFI para arrancar con grub desde la partición SRPBACKUP:
#    -Esa entrada aparecera con etiqueta SRP en la lista de entradas del firmware;
#    -Se crea dentro de la carpeta EFI de la particion EFI, la carpeta SRP para esta entrada.

grub-install --target=x86_64-efi --recheck --efi-directory=/mnt/EFI/ --boot-directory=/mnt/SRPBACKUP/boot/ --bootloader-id=SRP
`: `#!/bin/bash

# instalamos grup para arrancar con grub desde la partición SRPBACKUP en el mbr del disco a.
grub-install --no-floppy --root-directory=/mnt/SRPBACKUP /dev/sda
`;


            folder3.file(pEFI.activa ? 'CrearEntradaGrubEFI.sh' : 'InstalrGrubEnMBRsda.sh', herramienta);

            herramienta = `#!/bin/bash

## Ponemos en primer lugar del orden de arranque con el comando efibootmgr el arranque con SRP. 

# Obtener el número de la nueva entrada SRP creada, eliminando el asterisco
NEW_ENTRY=$(efibootmgr | grep "SRP" | awk '{print $1}' | sed -E 's/Boot([0-9]+)\\*/\\1/')

# Obtener las entradas actuales de arranque, eliminando posibles asteriscos
EXISTING_ENTRIES=$(efibootmgr | grep -E "Boot[0-9]+" | awk '{print $1}' | sed -E 's/Boot([0-9]+)\\*/\\1/')

# Crear una nueva lista de orden de arranque, eliminando duplicados
ORDER="$NEW_ENTRY,$(echo "$EXISTING_ENTRIES" | tr ' ' '\\n' | grep -v "^$NEW_ENTRY$" | tr '\\n' ',' | sed 's/,$//')"

# Cambiar el orden de arranque
echo "Estableciendo nuevo orden de arranque: $ORDER"
sudo efibootmgr -o $ORDER

# Ver el nuevo orden de arranque
echo "Nuevo orden de arranque:"
efibootmgr
`;
            //Solo si hay arranque UEFI
            if (pEFI.activa) {
                folder3.file('PonerPrimeraLaEntradaSRPenEFI.sh', herramienta);
            }
            if (pMAX.activa) {
                let folder4 = zip.folder("herramientas/MAX");
                herramienta = `#!/bin/bash

## Si hemos clonado MAX desde otro equipo, habrá que cambiar el nombre de equipo en MAX
## ya que al ser un clon mantendrá el del equipo de que procede.

# Comprobar si el script se ejecuta como superusuario
if [ "$(id -u)" -ne 0 ]; then
  echo "Este script debe ejecutarse como superusuario. Usa sudo."
  exit 1
fi

# Solicitar el nuevo nombre del equipo
read -p "Introduce el nuevo nombre para el equipo: " nuevo_nombre

# Cambiar el nombre del host en /etc/hostname
echo "$nuevo_nombre" > /etc/hostname

# Cambiar el nombre del host en /etc/hosts (asegurarse de que la dirección 127.0.1.1 coincida con el nombre del host)
sed -i "s/127.0.1.1.*/127.0.1.1   $nuevo_nombre/" /etc/hosts

# Aplicar el cambio de nombre del host
#hostname "$nuevo_nombre"
hostnamectl set-hostname "$nuevo_nombre"

# Confirmar que el cambio fue exitoso
echo "✅ El nombre del equipo ha sido cambiado a '$nuevo_nombre'."`;

                folder4.file('cambiarNombreEquipo.sh', herramienta);
                herramienta = `#!/bin/bash

## Normalmente en un aula de informatica los equipos de windows estan en una red
## dentro de un grupo de trabajo, con este escript se pretende facilitar que tras
## la instalacion de MAX los equipos configuren la red y el grupo de trabajo.

# Comprobar si el script se ejecuta como superusuario
if [ "$(id -u)" -ne 0 ]; then
  echo "Este script debe ejecutarse como superusuario. Usa sudo."
  exit 1
fi

# Solicitar el nombre del grupo de trabajo
read -p "Introduce el nuevo nombre del grupo de trabajo: " nuevo_grupo_trabajo

# Comprobar si Samba está instalado
if ! dpkg -l | grep -q samba; then
  echo "Samba no está instalado. Instalando Samba..."
  apt update && apt install -y samba
fi

# Modificar el archivo de configuración de Samba (/etc/samba/smb.conf)
sed -i "s/^workgroup = .*/workgroup = $nuevo_grupo_trabajo/" /etc/samba/smb.conf

# Reiniciar el servicio de Samba para aplicar los cambios
systemctl restart smbd

# Confirmar que el cambio fue exitoso
echo "El grupo de trabajo ha sido cambiado a '$nuevo_grupo_trabajo'."`;
                folder4.file('cambiar_grupo_trabajo.sh', herramienta);
                //Si solo se usa la particion SRP tanto para SystenRescueCD como para las carpetas coipia1, copia2,
                //no se crea partición para SRPBACKUP y por tanto no hay que ocultarla.
                let textoSRPBACKUP='" "/dev/sd' + pSRPBACKUP.disco + pSRPBACKUP.particion + '"'
                if((pSRP.disco + pSRP.particion)===(pSRPBACKUP.disco + pSRPBACKUP.particion))textoSRPBACKUP='"';
//                let herraux = ('"/dev/sd' + pSRP.disco + pSRP.particion + '" "/dev/sd' + pSRPBACKUP.disco + pSRPBACKUP.particion + '"');
                let herraux = ('"/dev/sd' + pSRP.disco + pSRP.particion + textoSRPBACKUP);
                if (pWin.activa) {
                    herraux += (' "/dev/sd' + pWin.disco + pWin.particion + '"');
                    if (pResW.activa) herraux += (' "/dev/sd' + pResW.disco + pResW.particion + '"');
                    if (pResW2.activa) herraux += (' "/dev/sd' + pResW2.disco + pResW2.particion + '"');
                }

                herramienta = `#!/bin/bash
## Tras la instalación de MAX, se montan automáticamente las particiones que usamos para administrar SRP${pWin.activa ? ` y
## las propias de windows, `: ',\n## '}como son particiones que los usuarios normales no es conveniente que pueda ni siquiera ver
## ya que si se hicieran cambios no autorizados podrían dañar el funcionamiento ${pWin.activa ? 'de windows y/o el' : 'del'} sistema de 
## restauración, con este script se pretende que queden sin montar y por tanto ocultas a los usuarios de MAX.
## Si el administrador del equipo precisara acceder a ellas conociendo sus discos y particiones de la configuración
## del disco/discos que se creo en el momento de elaborar el SRP (tambien se pueden ver usando gparted), puede proceder 
## a montarlas manualmente dentro de MAX.

# Asegúrate de que el script se ejecute como root
if [ "$(id -u)" -ne 0 ]; then
    echo "Este script debe ejecutarse como root. Usa sudo."
    exit 1
fi

# Lista de particiones a ocultar
particiones=(${herraux})
# Procesar cada partición
for particion in "`+ '${particiones[@]}' + `"; do
    # Obtener UUID y sistema de archivos
    UUID=$(blkid -s UUID -o value "$particion" 2>/dev/null)
    FSTYPE=$(blkid -s TYPE -o value "$particion" 2>/dev/null)

    # Verificar si la partición existe
    if [ -z "$UUID" ] || [ -z "$FSTYPE" ]; then
        echo "❌ La partición $particion no existe o no tiene un UUID válido. Se omitirá."
        continue
    fi

    # Verificar si ya está en /etc/fstab
    if grep -q "UUID=$UUID" /etc/fstab; then
        echo "✔ La partición $particion (UUID=$UUID) ya está en /etc/fstab. No se modificará."
    else
        echo "➕ Agregando $particion (UUID=$UUID) a /etc/fstab para evitar montaje automático..."
        echo "#La partición $particion se incluye para no ser montada en el arranque." >> /etc/fstab
        echo "UUID=$UUID none $FSTYPE noauto 0 0" >> /etc/fstab
    fi

    # Desmontar si ya está montada
    if findmnt -rno SOURCE "$particion" > /dev/null; then
        echo "🔹 Desmontando $particion..."
        umount "$particion"
    else
        echo "✔ $particion ya está desmontada."
    fi
done

echo "✅ Configuración completada. Las particiones de SRP ${pWin.activa ? 'y  Windows ' : ''}ya no se montarán automáticamente."
`;
                folder4.file('ocultar_particiones_SRP' + (pWin.activa ? '_windows' : '') + '.sh', herramienta);
            }
            let folder5 = zip.folder("herramientas/clonado");
            if (pEFI.activa) {
                //let folder5 = zip.folder("herramientas/clonado");
                herramienta = `#!/bin/bash

# Si se clona el disco ya configurado con carpetas para los distintos arranques en la 
# carpeta EFI en el nuevo equipo además del disco ya clonado es necesario crear
# en el firmware al menos la entrada para SRP para que desde ella mediante los menús 
# nos permita accdeder a los otros SO. (Windows suele crear la suya al arrancar si no
# encuentra una entrada para windows ya configurada y además la pone como primera, por
# lo que si es así tras el primer arranque de windows habrà  que volver a poner como
# primera la entrada SRP usando la herramienta PonerPrimeraLaEntradaSRPenEFI.sh.

# Crea en el firmware del equipo la entrada SRP apuntando a la carpeta EFI/SRP/grubx64.efi
efibootmgr --create --disk /dev/sd${pEFI.disco} --part ${pEFI.particion} --label "SRP" --loader '\\EFI\\SRP\\grubx64.efi'`;
                folder5.file('CreaEntradaSRPPostClonado.sh', herramienta);
            }
            herramienta = `#!/bin/bash
# ---------------------------------------------------------
# Servidor/Cliente NFS para intercambiar información entre
# los distintos equipos del aula conectados por red.
# El SERVIDOR expone a los clientes la carpeta /mnt/SRPBACKUP
# por defecto se expone en solo lectura (ro).
# los CLIENTES acceden al contenido de la carpeta expuesta en 
# la carpeta /mnt/NFS.
# Una vez actualizado el SO de un equipo y hecha la copia personalizada
# se puede arrancar el servidor NFS en ese equipo y arrancando
# clientes NFS en el resto de los equipos para copiar los archivos
# de la copia personalizada a la carpeta /mnt/SRPBACKUP/copia2 de dichos
# equipos que sustituiría a la version anterior. Restaurando la 
# copia personalizada en cada equipo tendríamos la nueva version del SO
# a falta de configurar el nombre de equipo.
# ---------------------------------------------------------
set -e

MOUNT_SRC="/mnt/SRPBACKUP"
MOUNT_DST="/mnt/NFS"
LABEL="SRPBACKUP"
CLIENT_NET="192.168.1.0/24"

# Opciones de exportación
EXPORT_OPTS_RW="rw,sync,no_subtree_check,no_root_squash,fsid=0"
EXPORT_OPTS_RO="ro,sync,no_subtree_check,fsid=0"

# ---------------------------------------------------------
# Utilidades
# ---------------------------------------------------------

detect_client_net() {
  # Interfaz usada para salir a la red
  local IFACE
  IFACE=$(ip route show default 0.0.0.0/0 | awk '{print $5}' | head -n1)

  if [ -z "$IFACE" ]; then
    echo "ERROR: No se pudo detectar la interfaz de red"
    exit 1
  fi

  # IP con prefijo (ej: 192.168.1.50/24)
  local IP_CIDR
  IP_CIDR=$(ip -4 -o addr show dev "$IFACE" | awk '{print $4}' | head -n1)

  if [ -z "$IP_CIDR" ]; then
    echo "ERROR: No se pudo obtener la IP de $IFACE"
    exit 1
  fi

  # Calcular red usando ipcalc si existe, si no, fallback simple
  if command -v ipcalc >/dev/null 2>&1; then
    CLIENT_NET=$(ipcalc -n "$IP_CIDR" | awk -F= '{print $2}')"/`+ '${IP_CIDR#*/}"\n' +
                `  else
    # Fallback simple: asume /24 (muy común)
    CLIENT_NET="$(echo "$IP_CIDR" | sed 's/\\.[0-9]\\+\\/.*/.0\\/24/')"
  fi
}


show_ip() {
  echo
  echo "IP(s) del servidor:"
  ip -4 -o addr show | awk '{print " - " $2 ": " $4}'
  echo
}

# ---------------------------------------------------------
# Permitiendo servir NFS en firewal SystemRescueCD
# ---------------------------------------------------------
setup_firewall_nfs() {
  echo "Configurando firewall para NFS..."

  iptables -P INPUT DROP
  iptables -P FORWARD DROP
  iptables -P OUTPUT ACCEPT

  iptables -F
  iptables -X

  # Permitir loopback
  iptables -A INPUT -i lo -j ACCEPT

  # Permitir conexiones establecidas
  iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

  # ICMP (ping)
  iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT

  # RPC / NFS
  iptables -A INPUT -p tcp --dport 111 -j ACCEPT
  iptables -A INPUT -p udp --dport 111 -j ACCEPT
  iptables -A INPUT -p tcp --dport 2049 -j ACCEPT
  iptables -A INPUT -p udp --dport 2049 -j ACCEPT
  iptables -A INPUT -p tcp --dport 20048 -j ACCEPT
  iptables -A INPUT -p udp --dport 20048 -j ACCEPT

  echo "Firewall NFS configurado"
}

# ---------------------------------------------------------
# Servidor
# ---------------------------------------------------------
start_server() {
  MODE="$1" # ro | rw
  [ "$MODE" != "rw" ] && MODE="ro"

  echo "=== MODO SERVIDOR ==="

  detect_client_net

  echo "Red detectada automáticamente: $CLIENT_NET"

  systemctl start rpcbind || true
  systemctl start nfs-server || systemctl start nfs || true
#  systemctl stop firewalld || true

  OPTS="$EXPORT_OPTS_RW"
  [ "$MODE" = "ro" ] && OPTS="$EXPORT_OPTS_RO"
  #echo "$MOUNT_SRC $CLIENT_NET(rw,sync,no_subtree_check,no_root_squash)" > /etc/exports
  echo "$MOUNT_SRC $CLIENT_NET(rw,sync,no_subtree_check,no_root_squash)" > /etc/exports
  echo "$MOUNT_SRC $CLIENT_NET($OPTS)" > /etc/exports
  exportfs -rav

  show_ip

  echo "Servidor NFS listo"
  echo "Exportando: $MOUNT_SRC ($MODE)"
  echo
  echo "NO CIERRES ESTA TERMINAL"
}

stop_server() {
  echo "Parando servidor NFS"
  systemctl stop nfs-server
  systemctl is-active nfs-server
  echo "Servidor detenido y limpio"
}

# ---------------------------------------------------------
# Cliente
# ---------------------------------------------------------
start_client() {
  SERVER_IP="$1"
  [ -z "$SERVER_IP" ] && {
    echo "Uso: $0 client <IP_SERVIDOR>"
    exit 1
  }

  echo "=== MODO CLIENTE ==="

  mkdir -p "$MOUNT_DST"

  #mount -t nfs "$SERVER_IP:$MOUNT_SRC" "$MOUNT_DST"
  mount -t nfs -o soft,nolock "$SERVER_IP:$MOUNT_SRC" "$MOUNT_DST"

  echo
  echo "NFS montado en $MOUNT_DST"
  echo "Ya puedes acceder desde el entorno gráfico"
}

stop_client() {
  echo "Desmontando cliente: $MOUNT_DST"
  umount "$MOUNT_DST"
}


case "$1" in
  server)
    setup_firewall_nfs
    start_server "$2"
    ;;
  stop-server)
    stop_server
    ;;
  client)
    start_client "$2"
    ;;
  stop-client)
    stop_client
    ;;
  *)
    echo "Uso:"
    echo "  $0 server [ro|rw]"
    echo "  $0 stop-server"
    echo "  $0 client <IP_SERVIDOR>"
    echo "  $0 stop-client"
    exit 1
    ;;
esac
`;
            folder5.file('srp_nfs.sh', herramienta);
            if (pWin.activa) {
                herramienta = `#!/bin/bash
# Este script permite realizar el BACKUP de Windows, la carpeta en que se 
# guarda se define desde el teclado igual que en las opciones ESPECIALES.
# El escript NO funciona en MODO GRAFICO, por lo que se debe ejecutar en una
# TERIMNAL AUTENTICA de TEXTO. 
# Si estamos en modo gráfico se puede salir desde el botón inicio seleccionando
# Log-Out y luego de nuevo Log-Out, o bien con Ctrl+Alt+F2.
#
# Si finalizado el script, queremos seguir en la sesisión de SystemRescueCD
# antes de que pasen los 30s de espera para reincialr se debe pulsar Ctrl+c
#

if [ -n "$DISPLAY" ]; then
    echo "ERROR: No ejecute este script desde el modo gráfico."
    echo "Puede hacer Log-Oou/Log-Out desde el boton inicio o"
    echo "cambie a una consola con Ctrl+Alt+F2 y ejecútelo allí."
    exit 1
fi

echo "Entorno correcto. Continuando..."
umount /dev/sd${pWin.disco}${pWin.particion}
cd  /run/archiso/bootmnt/autorun
chmod 755 *
./autorun1
./autorun6
mount /dev/sd${pWin.disco}${pWin.particion} /mnt/WIN`;
                folder5.file('BackupWin.sh', herramienta);
                herramienta = `#!/bin/bash
# Este script permite RESTAURAR WINDOWS, la carpeta desde la que se restaura
# se define desde el teclado igual que en las opciones ESPECIALES.
# El escript NO funciona en MODO GRAFICO, por lo que se debe ejecutar en una
# TERIMNAL AUTENTICA de TEXTO. 
# Si estamos en modo gráfico se puede salir desde el botón inicio seleccionando
# Log-Out y luego de nuevo Log-Out, o bien con Ctrl+Alt+F2.
#
# Si finalizado el script, queremos seguir en la sesisión de SystemRescueCD
# antes de que pasen los 30s de espera para reincialr se debe pulsar Ctrl+c
#

if [ -n "$DISPLAY" ]; then
    echo "ERROR: No ejecute este script desde el modo gráfico."
    echo "Puede hacer Log-Oou/Log-Out desde el boton inicio o"
    echo "cambie a una consola con Ctrl+Alt+F2 y ejecútelo allí."
    exit 1
fi

echo "Entorno correcto. Continuando..."
umount /dev/sd${pWin.disco}${pWin.particion}
cd  /run/archiso/bootmnt/autorun
chmod 755 *
./autorun1
./autorun4
mount /dev/sd${pWin.disco}${pWin.particion} /mnt/WIN`;
                folder5.file('RestauraWin.sh', herramienta);
            }
            if (pMAX.activa) {
                herramienta = `#!/bin/bash
# Este script permite realizar el BACKUP de Windows, la carpeta en que se 
# guarda se define desde el teclado igual que en las opciones ESPECIALES.
# El escript NO funciona en MODO GRAFICO, por lo que se debe ejecutar en una
# TERIMNAL AUTENTICA de TEXTO. 
# Si estamos en modo gráfico se puede salir desde el botón inicio seleccionando
# Log-Out y luego de nuevo Log-Out, o bien con Ctrl+Alt+F2.
#
# Si finalizado el script, queremos seguir en la sesisión de SystemRescueCD
# antes de que pasen los 30s de espera para reincialr se debe pulsar Ctrl+c
#

if [ -n "$DISPLAY" ]; then
    echo "ERROR: No ejecute este script desde el modo gráfico."
    echo "Puede hacer Log-Oou/Log-Out desde el boton inicio o"
    echo "cambie a una consola con Ctrl+Alt+F2 y ejecútelo allí."
    exit 1
fi

echo "Entorno correcto. Continuando..."
umount /dev/sd${pMAX.disco}${pMAX.particion}
cd  /run/archiso/bootmnt/autorun
chmod 755 *
./autorun1
./autorun7
mount /dev/sd${pMAX.disco}${pMAX.particion} /mnt/MAX`;
                folder5.file('BackupMax.sh', herramienta);
                herramienta = `#!/bin/bash
# Este script permite RESTAURAR MAX, la carpeta desde la que se restaura
# se define desde el teclado igual que en las opciones ESPECIALES.
# El escript NO funciona en MODO GRAFICO, por lo que se debe ejecutar en una
# TERIMNAL AUTENTICA de TEXTO. 
# Si estamos en modo gráfico se puede salir desde el botón inicio seleccionando
# Log-Out y luego de nuevo Log-Out, o bien con Ctrl+Alt+F2.
#
# Si finalizado el script, queremos seguir en la sesisión de SystemRescueCD
# antes de que pasen los 30s de espera para reincialr se debe pulsar Ctrl+c
#

if [ -n "$DISPLAY" ]; then
    echo "ERROR: No ejecute este script desde el modo gráfico."
    echo "Puede hacer Log-Oou/Log-Out desde el boton inicio o"
    echo "cambie a una consola con Ctrl+Alt+F2 y ejecútelo allí."
    exit 1
fi

echo "Entorno correcto. Continuando..."
umount /dev/sd${pMAX.disco}${pMAX.particion}
cd  /run/archiso/bootmnt/autorun
chmod 755 *
./autorun1
./autorun5
mount /dev/sd${pMAX.disco}${pMAX.particion} /mnt/MAX`;
                folder5.file('RestauraMax.sh', herramienta);
            }
            let folder6 = zip.folder("herramientas/VirtualBox");
            herramienta = `#!/bin/bash
# En las pruebas mediante máquinas virtuales de VirtualBox
# para poder intercambiar información entre el host y las
# máquinas virtuales se puede utilizar las CARPETAS COMPARTIDAS 
# de VirtualBox.
#
# Para visualizar la carpeta compartida en VirtualBox en SRP
# arrancando SystemRescueCD, la carpeta compartida se comparte
# con el nombre SRP_HOST en la cofiguracion de la máquina de 
# VirtualBox y aparece montada en el SystemRescueCD de la máquina
# virtual en la carpeta  /mnt/host cuando se ejecuta este script.

mkdir -p /mnt/host
mount -t vboxsf SRP_HOST /mnt/host
echo "La carpeta compartida con el nombre SRP_HOST en VirtualBox estará montada en: /mnt/host"`;
            folder6.file('CarpetaCompartidaVirtualBoxSRP.sh', herramienta);


            //CARGAMOS LOS FONDOS DE LOS MENUS
            cargarImagenes(zip).then(() => {
                zip.generateAsync({ type: "blob" }).then(function (content) {
                    let a = document.createElement("a");
                    a.href = URL.createObjectURL(content);
                    a.download = "srp.zip";
                    a.click();
                });
            });
        }
        const numDisco = (letra) => {
            switch (letra) {
                case 'a': return 0;
                case 'b': return 1;
                case 'c': return 2;
                case 'd': return 3;
                case 'e': return 4;
                case 'f': return 5;
                case 'g': return 6;
                case 'h': return 7;
            }
        }
        function reemplazarTexto(inputText, name, replacement) {
            //let inputText = document.getElementById("inputText").value;
            //let name = document.getElementById("searchName").value;
            //let replacement = document.getElementById("replaceText").value;

            let marcaIni = "##--" + name + "--##";
            let marcaFin = "##--fin " + name + "--##";
            let aux = inputText.split(marcaIni);
            let cabecera = aux[0];//alert(cabecera)
            aux = aux[1].split(marcaFin);
            let cola = aux[1];
            let result = cabecera + marcaIni + '\n' + replacement + '\n' + marcaFin + cola;

            //let regex = new RegExp("##--" + name + "--##([\\s\S]*?)##--fin " + name + "--##", "g");
            //let result = inputText.replace(regex, `##--${name}--##\n${replacement}\n##--fin ${name}--##`);

            //document.getElementById("outputText").value = result;
            return result
        }

        //para generar la encriptacion de la contraseña, es un proceso lento que se lanza en paralelo y se chequea que esta encriptada mediante este semaforo

        let estaEncriptada = false
        function generatePBKDF2() {
            // Obtención de los valores introducidos
            const password = document.getElementById('password').value;
            const iterations = 10000;// parseInt(document.getElementById('iterations').value, 10);
            const keylen = 64;// parseInt(document.getElementById('keylen').value, 10);

            if (password === '') {
                alert("Por favor, ingresa una contraseña.");
                return;
            }

            //const saltHex = "C40F196D0D81371D66A88443FC8697C1E7695B88F33A9B371C4FF379D7380622F8C828292B617868B4A8746D30AFE25B37606C1D8E015EE49F5415F822D8D18E"; // Salt en HEX
            let simbolos = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
            let saltHex = '';
            for (let i = 0; i < 128; i++) {
                let aux = Math.floor(16 * Math.random())
                saltHex += simbolos[aux];
            }
            //const iterations = 10000;
            const keySizeBytes = keylen//64; // 64 bytes para SHA512

            // Convertir salt de HEX a WordArray (formato requerido por CryptoJS)
            const salt = CryptoJS.enc.Hex.parse(saltHex);

            // Generar clave PBKDF2 en hexadecimal
            const derivedKey = CryptoJS.PBKDF2(password, salt, {
                keySize: keySizeBytes / 4, // CryptoJS usa "palabras" de 32 bits, 64 bytes = 16 palabras
                iterations: iterations,
                hasher: CryptoJS.algo.SHA512
            });

            // Convertir clave derivada a HEX y asegurarse de que esté en mayúsculas
            const derivedKeyHex = derivedKey.toString(CryptoJS.enc.Hex).toUpperCase();

            // Formato final igual a GRUB
            const grubHash = `grub.pbkdf2.sha512.${iterations}.${saltHex}.${derivedKeyHex}`;


            document.getElementById('hashedPassword').value = grubHash;
            document.getElementById('hashedPassword').style.visibility = 'visible';
            //document.getElementById('result').style.display = 'block';
            estaEncriptada = true;
        }
        //funcion para ver que las contrseñas solo sean letras y numeros
        function validarTexto(input) {
            // Expresión regular que permite solo letras (mayúsculas y minúsculas) y números
            const regex = /^[A-Za-z0-9]+$/;

            // Verifica si el valor cumple con la expresión regular
            return regex.test(input);
        }

    </script>
</body>

</html>