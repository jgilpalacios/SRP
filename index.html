<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de Particiones</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px;
            cursor: pointer;
            border: 1px solid black;
        }

        .active {
            background-color: lightgray;
            border-width: 3px;
        }

        .menu {
            display: none;
            border: 1px solid black;
            padding: 10px;
        }

        .visible {
            display: block;
        }

        /*carga de configuracion */
        .card {
            border: 1px solid #e5e7eb;
            padding: 1rem 1.25rem;
            border-radius: 8px;
            max-width: 720px;
        }

        button {
            /*padding: .5rem .75rem;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            background: white;*/
            cursor: pointer;
        }

        pre {
            white-space: pre-wrap;
            background: #f8fafc;
            padding: .75rem;
            border-radius: 6px;
            overflow-x: auto;
        }

        .ok {
            color: #065f46;
        }

        .err {
            color: #b91c1c;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="./autorun.js"></script>
    <script src="./srp.js"></script>
</head>

<body>
    <h1>Gestor de Particiones</h1>
    <hr>
    <p><span style="visibility: hidden;"><label for="numDiscos">N√∫mero de discos:</label>
            <select id="numDiscos" onchange="actualizarDiscos()">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4" selected>4</option>
            </select></span>TRAS HABER CREADO Y CONFIGURADO LAS PARTICIONES NECESARIAS CON GPARTED<br />
        Abre una consola en el escritorio y ejecuta la orden:<br />
        <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lsblk -J -b -o
            NAME,KNAME,PATH,TYPE,TRAN,SIZE,MODEL,SERIAL,FSTYPE,MOUNTPOINT,UUID,PARTUUID,LABEL > bloques.json</b><br />
        y carga el archivo <u>bloques.json</u> con el siguiente bot√≥n <u>para identificar correctamente los discos y
            particiones</u> en sistemas con NVMe, SATA.... <u>y cargarlos en el configurador</u><br />
        <input type="file" id="fileInputDisco" accept=".json">
        <hr>


        <!-- Bot√≥n visible que abre el input oculto -->
        Si ya configuraste un equipo y quieres repetir su configuraci√≥n en otro:<button id="selectBtn">Cargar
            configuraci√≥n.txt</button>

        <!-- input de archivo oculto (acepta .txt). No forzar√° nombre, por eso verificamos en JS -->
        <input id="fileInput" type="file" accept=".txt,text/plain" style="display:none" />

        <!-- Selecciona archivo particiones.txt -->
        <label><input type="checkbox" id="chkUUID"
                title="Si se selecciona se deben cargar las UUIDs de las particiones de cada equipo a instalar el SRP" />
            Usar UUID</label>
        <span id="uuidSection" style="display:none;">
            Ejecuta en una terminal la orden: <b>blkid -s UUID>particiones.txt</b>
            <button id="selectPartBtn">Buscar particiones.txt</button>
            <input id="partFileInput" type="file" accept=".txt,text/plain" style="display:none" /></span>
    </p>


    <div class="tabs" id="tabs"></div>
    <div id="menu" class="menu"></div>
    <button onclick="comprobarErrores()">Comprobaci√≥n</button><button onclick="generarZip()">Descargar SRP.ZIP</button>
    <h4>Info: <a href="https://www.educa2.madrid.org/web/jgilpalacios/srp"
            target="_blank">https://www.educa2.madrid.org/web/jgilpalacios/</a></h4>
    <h4>Info: <a href="https://jgilpalacios.neocities.org/SRP/info/"
            target="_blank">https://jgilpalacios.neocities.org/SRP/info/</a></h4>
    <p id="error"></p>
    <div id="discos"></div>
    <!--Parseador-->
    <span id="cargarConfResultado" style="visibility: hidden;">
        <p>Estado: <span id="status">No hay archivo seleccionado</span></p>
        <p>Nombre del archivo: <strong id="fileName">‚Äî</strong></p>

        <h3>Contenido (si se pudo leer)</h3>
        <pre id="fileContent">‚Äî</pre>
    </span>
    <script>
        let seHaCargadoUUIDsFile = false;
        let configuracion = {
            users: [{ nombre: 'madrid', pass: 'cmadrid', enc: false }, { nombre: 'consejeria', pass: 'cconsejeria', enc: true }],
            nDiscos: 4,
            particiones: [
                { nombre: 'EFI', particionEFI: { disco: 'sda', particion: 1, activa: true } },
                { nombre: 'SRP', particionSRP: { disco: 'sda', particion: 7, activa: true }, particionSRPBACKUP: { disco: 'sda', particion: 8, activa: true } },
                { nombre: 'WINDOWS', particionWIN: { disco: 'sda', particion: 3, activa: true }, particionRES: { disco: 'sda', particion: 4, activa: true }, particionRES2: { disco: 'sda', particion: 4, activa: false } },
                { nombre: 'MAX', particionMAX: { disco: 'sda', particion: 5, activa: true }, particionSWAP: { disco: 'sda', particion: 6, activa: true } }
            ]
        };
        ///GESION DE NVME
        document.getElementById("fileInputDisco").addEventListener("change", function (e) {
            const file = e.target.files[0];
            const reader = new FileReader();

            reader.onload = function (evt) {
                const data = JSON.parse(evt.target.result);
                procesarBloques(data.blockdevices);
            };

            reader.readAsText(file);
        });
        let namespaces = [];
        function procesarBloques(devices) {
            namespaces = [];//reiniciamos el array de namespaces para que luego al cargar los discos desde el archivo bloques.json s√≥lo se muestren los discos que correspondan con los de la configuraci√≥n cargada, aunque si no se ha cargado el archivo bloques.json se mostrar√°n todos los discos igual que antes.
            const cont = document.getElementById("discos");
            cont.innerHTML = "";
            let discosTotales = 0;
            let yaEstaEfiAsignada = false;
            devices
                .filter(d => d.type === "disk")   // üëà namespaces NVMe + discos SATA
                .forEach((disk, i) => {
                    //discosTotales++;
                    if (disk.name.startsWith('nvme')) disk.name += 'p';//en nvme las particiones se nombran con una p entre el nombre del disco y el n√∫mero de partici√≥n, por ejemplo nvme0n1p1, mientras que en sata es sdax donde x es la letra del disco y el n√∫mero de partici√≥n va justo despu√©s sin p, por ejemplo nvem0n1p1 vs sda1, por eso a√±adimos la p al nombre del disco nvme para luego identificar correctamente las particiones
                    if (disk.name.startsWith('mmcblk')) disk.name += 'p';//en mmcblk ocurre lo mismo que en nvme, las particiones se nombran con una p entre el nombre del disco y el n√∫mero de partici√≥n, por ejemplo mmcblk0p1, mientras que en sata es sdax donde x es la letra del disco y el n√∫mero de partici√≥n va justo despu√©s sin p, por ejemplo mmcblk0p1 vs sda1, por eso a√±adimos la p al nombre del disco mmcblk para luego identificar correctamente las particiones
                    namespaces.push(disk);
                    const div = document.createElement("div");

                    div.innerHTML = `
        <h3>Disco ${i + 1}</h3>
        Nombre: ${disk.name} <br>
        Tipo: ${disk.tran} <br>
        Tama√±o: ${disk.size} <br>
        Modelo: ${disk.model || "?"}
        <br><strong>Particiones:</strong>
      `;

                    if (disk.children) {
                        discosTotales++;
                        disk.children.forEach((p, i) => {
                            if (i === 0 && discosTotales === 1) {
                                //si es la primera partici√≥n del primer disco, que suele ser la EFI, la asignamos autom√°ticamente a la configuraci√≥n para que se muestre seleccionada en el men√∫ sin necesidad de cargar las UUIDs desde el archivo particiones.txt, aunque si se carga el archivo particiones.txt se actualizar√°n las UUIDs asignadas a cada partici√≥n
                                configuracion.particiones[0].particionEFI.disco = disk.name;
                                configuracion.particiones[0].particionEFI.particion = 1;
                                configuracion.particiones[0].particionEFI.UUID = p.uuid;
                                //iniciamos igual por defecto el resto de particiones de la configuracion para que correspondan con una partici√≥n real de los discos.
                                configuracion.particiones[1].particionSRP.disco = disk.name;
                                configuracion.particiones[1].particionSRP.particion = 1;
                                configuracion.particiones[1].particionSRP.UUID = p.uuid;
                                configuracion.particiones[1].particionSRPBACKUP.disco = disk.name;
                                configuracion.particiones[1].particionSRPBACKUP.particion = 1;
                                configuracion.particiones[1].particionSRPBACKUP.UUID = p.uuid;
                                configuracion.particiones[3].particionMAX.disco = disk.name;
                                configuracion.particiones[3].particionMAX.particion = 1;
                                configuracion.particiones[3].particionMAX.UUID = p.uuid;
                                configuracion.particiones[3].particionSWAP.disco = disk.name;
                                configuracion.particiones[3].particionSWAP.particion = 1;
                                configuracion.particiones[3].particionSWAP.UUID = p.uuid;
                                configuracion.particiones[2].particionWIN.disco = disk.name;
                                configuracion.particiones[2].particionWIN.particion = 1;
                                configuracion.particiones[2].particionWIN.UUID = p.uuid;
                                configuracion.particiones[2].particionRES.disco = disk.name;
                                configuracion.particiones[2].particionRES.particion = 1;
                                configuracion.particiones[2].particionRES.UUID = p.uuid;
                                configuracion.particiones[2].particionRES2.disco = disk.name;
                                configuracion.particiones[2].particionRES2.particion = 1;
                                configuracion.particiones[2].particionRES2.UUID = p.uuid;
                            }
                            if (p.label) {
                                if (p.label === 'EFI'&& !yaEstaEfiAsignada) {
                                    //si la partici√≥n se llama EFI, la asignamos autom√°ticamente a la configuraci√≥n para que se muestre seleccionada en el men√∫ sin necesidad de cargar las UUIDs desde el archivo particiones.txt, aunque si se carga el archivo particiones.txt se actualizar√°n las UUIDs asignadas a cada partici√≥n
                                    configuracion.particiones[0].particionEFI.disco = disk.name;
                                    configuracion.particiones[0].particionEFI.particion = i + 1;
                                    configuracion.particiones[0].particionEFI.UUID = p.uuid;
                                    yaEstaEfiAsignada = true;
                                } else if (p.label === 'SRP') {
                                    //si la partici√≥n se llama SRP, la asignamos autom√°ticamente a la configuraci√≥n para que se muestre seleccionada en el men√∫ sin necesidad de cargar las UUIDs desde el archivo particiones.txt, aunque si se carga el archivo particiones.txt se actualizar√°n las UUIDs asignadas a cada partici√≥n
                                    configuracion.particiones[1].particionSRP.disco = disk.name;
                                    configuracion.particiones[1].particionSRP.particion = i + 1;
                                    configuracion.particiones[1].particionSRP.UUID = p.uuid;
                                } else if (p.label === 'SRPBACKUP') {
                                    //si la partici√≥n se llama SRPBACKUP, la asignamos autom√°ticamente a la configuraci√≥n para que se muestre seleccionada en el men√∫ sin necesidad de cargar las UUIDs desde el archivo particiones.txt, aunque si se carga el archivo particiones.txt se actualizar√°n las UUIDs asignadas a cada partici√≥n
                                    configuracion.particiones[1].particionSRPBACKUP.disco = disk.name;
                                    configuracion.particiones[1].particionSRPBACKUP.particion = i + 1;
                                    configuracion.particiones[1].particionSRPBACKUP.UUID = p.uuid;
                                } else if (p.label === 'MAX') {
                                    //si la partici√≥n se llama MAX, la asignamos autom√°ticamente a la configuraci√≥n para que se muestre seleccionada en el men√∫ sin necesidad de cargar las UUIDs desde el archivo particiones.txt, aunque si se carga el archivo particiones.txt se actualizar√°n las UUIDs asignadas a cada partici√≥n
                                    configuracion.particiones[3].particionMAX.disco = disk.name;
                                    configuracion.particiones[3].particionMAX.particion = i + 1;
                                    configuracion.particiones[3].particionMAX.UUID = p.uuid;
                                } else if (p.label.toLowerCase() === 'windows') {
                                    //si la partici√≥n se llama Windows, la asignamos autom√°ticamente a la configuraci√≥n para que se muestre seleccionada en el men√∫ sin necesidad de cargar las UUIDs desde el archivo particiones.txt, aunque si se carga el archivo particiones.txt se actualizar√°n las UUIDs asignadas a cada partici√≥n
                                    configuracion.particiones[2].particionWIN.disco = disk.name;
                                    configuracion.particiones[2].particionWIN.particion = i + 1;
                                    configuracion.particiones[2].particionWIN.UUID = p.uuid;
                                } else if (p.label === 'WINRE') {
                                    //si la partici√≥n se llama WINRE, la asignamos autom√°ticamente a la configuraci√≥n para que se muestre seleccionada en el men√∫ sin necesidad de cargar las UUIDs desde el archivo particiones.txt, aunque si se carga el archivo particiones.txt se actualizar√°n las UUIDs asignadas a cada partici√≥n
                                    configuracion.particiones[2].particionRES.disco = disk.name;
                                    configuracion.particiones[2].particionRES.particion = i + 1;
                                    configuracion.particiones[2].particionRES.UUID = p.uuid;
                                } else if (p.label === 'reservado para el sistema') {
                                    //si la partici√≥n se llama reservado para el sistema, la asignamos autom√°ticamente a la configuraci√≥n para que se muestre seleccionada en el men√∫ sin necesidad de cargar las UUIDs desde el archivo particiones.txt, aunque si se carga el archivo particiones.txt se actualizar√°n las UUIDs asignadas a cada partici√≥n
                                    configuracion.particiones[2].particionRES.disco = disk.name;
                                    configuracion.particiones[2].particionRES.particion = i + 1;
                                    configuracion.particiones[2].particionRES.UUID = p.uuid;
                                }
                            }
                            if (p.fstype && p.fstype.toLowerCase().includes('swap')) {
                                //si la partici√≥n es de tipo swap, la asignamos autom√°ticamente a la configuraci√≥n para que se muestre seleccionada en el men√∫ sin necesidad de cargar las UUIDs desde el archivo particiones.txt, aunque si se carga el archivo particiones.txt se actualizar√°n las UUIDs asignadas a cada partici√≥n
                                configuracion.particiones[3].particionSWAP.disco = disk.name;
                                configuracion.particiones[3].particionSWAP.particion = i + 1;
                                configuracion.particiones[3].particionSWAP.UUID = p.uuid;
                            }
                            const pDiv = document.createElement("div");
                            pDiv.textContent = `‚Ü≥ ${p.name} (${p.fstype || "sin FS"}) - ${p.size} - ${p.mountpoint || "no montada"} - ${p.uuid || "sin UUID"} - ${p.partuuid || "sin PARTUUID"}`;
                            div.appendChild(pDiv);
                        });
                    }

                    cont.appendChild(div);
                });
            discosDesdeConfiguracion = [];//reiniciamos el array de discos desde configuraci√≥n para que luego al cargar los bloques.json con los namespaces de los discos nvme, se muestren s√≥lo los discos que correspondan con los de la configuraci√≥n cargada, aunque si no se ha cargado el archivo bloques.json se mostrar√°n todos los discos igual que antes.
            configuracion.nDiscos = discosTotales;
            document.getElementById("chkUUID").checked = true;
            configuracion.usarUUID = true;
            seHaCargadoUUIDsFile = true;
            cargarTabs();
            //alert(JSON.stringify(namespaces));
        }



        //////////FIN GESTION NVME
        //////////
        let configuraci√≥nContenido = null; // contiene el texto del archivo (string)

        const selectBtn = document.getElementById('selectBtn');
        const fileInput = document.getElementById('fileInput');
        const statusEl = document.getElementById('status');
        const fileNameEl = document.getElementById('fileName');
        const fileContentEl = document.getElementById('fileContent');

        // Abrir di√°logo de archivos al pulsar el bot√≥n
        selectBtn.addEventListener('click', () => fileInput.click());

        // Manejar la selecci√≥n de archivo
        fileInput.addEventListener('change', async (event) => {
            document.getElementById('cargarConfResultado').style.visibility = 'visible';
            const file = fileInput.files[0];
            if (!file) return; // usuario cancel√≥

            // Comprobamos el nombre exacto solicitado
            // Nota: aqu√≠ se comprueba exactamente 'configuraci√≥n.txt' (con tilde).
            // Si quieres aceptar tambi√©n 'configuracion.txt' sin tilde, a√±ade esa condici√≥n.
            const expectedName = 'configuraci√≥n.txt';
            if (file.name !== expectedName) {
                alert('El archivo debe llamarse ' + expectedName);
                statusEl.textContent = 'Archivo incorrecto: se esperaba "' + expectedName + '" no "' + file.name + '".';
                statusEl.className = 'err';
                fileNameEl.textContent = file.name;
                fileContentEl.textContent = 'El archivo seleccionado no se llama "' + expectedName + '".';
                // Limpiamos la selecci√≥n para permitir volver a elegir el mismo archivo si se desea
                fileInput.value = '';
                configuraci√≥n = null;
                configuraci√≥nContenido = null;
                return;
            }

            // Si llegamos aqu√≠, el nombre coincide -> asignamos a la variable 'configuraci√≥n'
            configuraci√≥n = file; // objeto File de la API File
            statusEl.textContent = 'Archivo v√°lido seleccionado';
            statusEl.className = 'ok';
            fileNameEl.textContent = file.name;

            try {
                // Leer contenido como texto (File.text() devuelve una Promise)
                configuraci√≥nContenido = await file.text();
                fileContentEl.textContent = configuraci√≥nContenido;
                procesarConfiguraci√≥n(configuraci√≥nContenido)
            } catch (err) {
                fileContentEl.textContent = 'Error leyendo el archivo: ' + err;
            }
            // Aqu√≠ puedes usar la variable 'configuraci√≥n' y 'configuraci√≥nContenido' en tu c√≥digo
            // por ejemplo: procesarConfiguraci√≥n(configuraci√≥nContenido);
        });

        // Ejemplo de funci√≥n que podr√≠a usar la configuraci√≥n ya le√≠da
        function procesarConfiguraci√≥n(texto) {

            // parsear, dividir por l√≠neas, JSON.parse, etc. seg√∫n formato de tu archivo
            configuracion = JSON.parse(texto);
            //alert(JSON.stringify(configuracion));
            if (configuracion.particiones[0].particionEFI.activa) {
                discosDesdeConfiguracion.push(configuracion.particiones[0].particionEFI.disco);
            }
            let aux = configuracion.particiones[1].particionSRP.disco;
            if (discosDesdeConfiguracion.indexOf(aux) === -1) {
                discosDesdeConfiguracion.push(aux);
            }
            aux = configuracion.particiones[1].particionSRPBACKUP.disco;
            if (configuracion.particiones[1].particionSRPBACKUP.activa && discosDesdeConfiguracion.indexOf(aux) === -1) {
                discosDesdeConfiguracion.push(aux);
            }
            aux = configuracion.particiones[2].particionWIN.disco;
            if (configuracion.particiones[2].particionWIN.activa && discosDesdeConfiguracion.indexOf(aux) === -1) {
                discosDesdeConfiguracion.push(aux);
            }
            aux = configuracion.particiones[2].particionRES.disco;
            if (configuracion.particiones[2].particionRES.activa && discosDesdeConfiguracion.indexOf(aux) === -1) {
                discosDesdeConfiguracion.push(aux);
            }
            aux = configuracion.particiones[2].particionRES2.disco;
            if (configuracion.particiones[2].particionRES2.activa && discosDesdeConfiguracion.indexOf(aux) === -1) {
                discosDesdeConfiguracion.push(aux);
            }
            aux = configuracion.particiones[3].particionMAX.disco;
            if (configuracion.particiones[3].particionMAX.activa && discosDesdeConfiguracion.indexOf(aux) === -1) {
                discosDesdeConfiguracion.push(aux);
            }
            aux = configuracion.particiones[3].particionSWAP.disco;
            if (configuracion.particiones[3].particionSWAP.activa && discosDesdeConfiguracion.indexOf(aux) === -1) {
                discosDesdeConfiguracion.push(aux);
            }
            discosDesdeConfiguracion.sort();
            configuracion.nDiscos = discosDesdeConfiguracion.length;
            namespaces=[];//limpiamos el array de namespaces para que luego al cargar los discos desde el archivo bloques.json s√≥lo se muestren los discos que correspondan con los de la configuraci√≥n cargada, aunque si no se ha cargado el archivo bloques.json se mostrar√°n todos los discos igual que antes.
            cargarTabs();
            console.log('Procesando configuraci√≥n:', texto);
        }
        let discosDesdeConfiguracion = [];
        ////Asignamos las UUID de las particiones desde el archivo particiones.txt
        const selectPartBtn = document.getElementById('selectPartBtn');
        const partFileInput = document.getElementById('partFileInput');

        let particionesContenido = null;

        // Mostrar/ocultar bot√≥n seg√∫n checkbox
        const chkUUID = document.getElementById('chkUUID');
        chkUUID.addEventListener('change', () => {
            configuracion.usarUUID = chkUUID.checked;
            selectPartBtn.style.display = chkUUID.checked ? 'inline-block' : 'none';
            document.getElementById('uuidSection').style.display = chkUUID.checked ? 'inline' : 'none';
        });

        selectPartBtn.addEventListener('click', () => partFileInput.click());

        partFileInput.addEventListener('change', async () => {
            const file = partFileInput.files[0];
            if (!file) return;
            document.getElementById('cargarConfResultado').style.visibility = 'visible';
            // Comprobamos el nombre exacto solicitado
            const expectedName = 'particiones.txt';
            if (file.name !== expectedName) {
                alert('El archivo debe llamarse ' + expectedName);
                statusEl.textContent = 'Archivo incorrecto: se esperaba "' + expectedName + '" no "' + file.name + '".';
                statusEl.className = 'err';
                fileNameEl.textContent = file.name;
                fileContentEl.textContent = 'El archivo seleccionado no se llama "' + expectedName + '".';
                // Limpiamos la selecci√≥n para permitir volver a elegir el mismo archivo si se desea
                //fileInput.value = '';
                partFileInput.value = '';



                return;
            }
            statusEl.textContent = 'Archivo v√°lido seleccionado';
            statusEl.className = 'ok';
            fileNameEl.textContent = file.name;

            try {
                // Leer contenido como texto (File.text() devuelve una Promise)
                particionesContenido = await file.text();
                fileContentEl.textContent = particionesContenido;
                asignarUUIDs();
            } catch (err) {
                fileContentEl.textContent = 'Error leyendo el archivo: ' + err;
            }

            //particionesContenido = await file.text();

            //asignarUUIDs();
        });

        function asignarUUIDs() {
            /*if (!configuraci√≥nContenido) {
              alert('Primero carga configuraci√≥n.txt');
              return;
            }*/
            if (!particionesContenido) {
                alert('Primero carga particiones.txt');
                return;
            }

            let conf;
            try {
                //conf = JSON.parse(configuraci√≥nContenido);
                conf = configuracion;
            } catch (e) {
                alert('Error al parsear configuraci√≥n: ' + e);
                return;
            }

            const lineas = particionesContenido.split("\n").filter(l => l.trim() !== "");
            const mapaUUID = {};
            const arrUUID = [];
            for (const l of lineas) {
                const partes = l.split(':');
                if (partes.length >= 2) {
                    const dev = partes[0].trim();
                    const uuid = partes[1].trim();
                    mapaUUID[dev] = uuid;
                    arrUUID.push(uuid);
                }
            }
            let error = false
            arrUUID.forEach((uuid, index) => {
                for (let j = 0; j < index; j++) {
                    if (arrUUID[j] === uuid) {
                        alert('Atenci√≥n: La UUID ' + uuid + ' est√° duplicada en el archivo particiones.txt');
                        error = true;
                        return;
                    }
                }
            });
            if (error) return;

            for (const part of conf.particiones) {
                for (const key of Object.keys(part)) {
                    if (key.startsWith('particion')) {
                        const p = part[key];
                        p.UUID = null; // resetear antes
                        if (p.activa) {
                            const nombreDev = `/dev/${p.disco}${p.particion}`;
                            if (mapaUUID[nombreDev]) {
                                p.UUID = mapaUUID[nombreDev].split('"')[1];
                            } else {
                                p.UUID = null;
                            }
                        }
                    }
                }
            }
            cargarTabs();
            seHaCargadoUUIDsFile = true;
            console.log('Configuraci√≥n actualizada:', conf);

        }
        /////////

        function actualizarDiscos() {
            let numDiscos = document.getElementById("numDiscos").value;
            configuracion.nDiscos = numDiscos;
            cargarTabs();
        }
        //para gestionar las contrase√±as en srp
        let srp_tab;
        function cargarTabs() {
            const tabs = document.getElementById("tabs");
            tabs.innerHTML = "";
            let srp_index = 1;

            if (configuracion.usarUUID) {
                document.getElementById('chkUUID').checked = true;
                document.getElementById('uuidSection').style.display = 'inline';
                selectPartBtn.style.display = 'inline-block';
            } else {
                document.getElementById('chkUUID').checked = false;
                document.getElementById('uuidSection').style.display = 'none';
                selectPartBtn.style.display = 'none';
            }

            configuracion.particiones.forEach((particion, index) => {
                let tab = document.createElement("div");
                tab.className = "tab";
                tab.id = particion.nombre + '_tab';
                tab.innerText = particion.nombre;
                tab.style.backgroundColor = `hsl(${index * 60}, 70%, 80%)`;
                tab.onclick = () => mostrarMenu(index, tab);
                tabs.appendChild(tab);
                if (index === srp_index) srp_tab = tab;
                const menu = document.getElementById("menu");
                menu.innerHTML = "";
                document.getElementById("error").innerText = '';
            });
            //se pone para activar srp y inicializar todo
            mostrarMenu(srp_index, srp_tab)
        }
        //para gestionar las contrase√±as en srp se crean como variables globales
        let contrasenna = document.createElement("input");
        contrasenna.type = 'password';
        contrasenna.value = configuracion.users[0].pass;
        contrasenna.title = 'Utilize s√≥lo letras y n√∫meros para la contrase√±a,\nLas letras acentuadas y la letra √± no son v√°lidas.';
        contrasenna.onmouseover = () => { contrasenna.type = 'text' }
        contrasenna.onmouseout = () => { contrasenna.type = 'password' }
        contrasenna.onchange = () => {
            if (validarTexto(contrasenna.value)) configuracion.users[0].pass = contrasenna.value;
            else {
                alert('Utilize s√≥lo letras y n√∫meros para la contrase√±a,\nLas letras acentuadas y la letra √± no son v√°lidas.');
                contrasenna.value = configuracion.users[0].pass;
            }
        }

        let ccontrasenna = document.createElement("input");
        ccontrasenna.id = 'password';
        ccontrasenna.type = 'password';
        ccontrasenna.value = configuracion.users[1].pass;
        setTimeout(generatePBKDF2, 1);//lanzamos en paralelo la encriptacion
        ccontrasenna.title = 'Utilize s√≥lo letras y n√∫meros para la contrase√±a,\nLas letras acentuadas y la letra √± no son v√°lidas.';
        ccontrasenna.onmouseover = () => { ccontrasenna.type = 'text' }
        ccontrasenna.onmouseout = () => { ccontrasenna.type = 'password' }
        ccontrasenna.onchange = () => {
            estaEncriptada = false;
            document.getElementById('hashedPassword').style.visibility = 'hidden';
            if (validarTexto(ccontrasenna.value)) {
                configuracion.users[1].pass = ccontrasenna.value;
                setTimeout(generatePBKDF2, 1);//lanzamos en paralelo la encriptacion
            } else {
                alert('Utilize s√≥lo letras y n√∫meros para la contrase√±a,\nLas letras acentuadas y la letra √± no son v√°lidas.');
                ccontrasenna.value = configuracion.users[1].pass;
            }
        }

        let hashedPassword = document.createElement("input");
        hashedPassword.type = 'text';
        hashedPassword.id = 'hashedPassword';
        hashedPassword.title = 'Haz doble click para copiar en el portapapeles la contrase√±a encriptada';
        hashedPassword.ondblclick = () => {
            hashedPassword.select(); // Selecciona el texto
            document.execCommand("copy"); // Copia el texto al portapapeles
        }
        hashedPassword.style.visibility = 'hidden';
        let indexActual, tabActual;
        function mostrarMenu(index, tab) {
            indexActual = index;
            tabActual = tab;
            const menu = document.getElementById("menu");
            menu.innerHTML = "";
            menu.style.backgroundColor = tab.style.backgroundColor;
            let particion = configuracion.particiones[index];

            document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
            tab.classList.add("active");
            //if(contenidoTab[index]===undefined){
            Object.keys(particion).forEach(clave => {
                if (clave !== "nombre") {
                    let div = document.createElement("div");
                    let label = document.createElement("label");
                    label.innerText = clave + ": ";
                    let select = document.createElement("select");

                    if (namespaces.length === 0) {
                        for (let i = 1; i <= 20; i++) {
                            let option = document.createElement("option");
                            option.value = i;
                            option.innerText = i;
                            if (particion[clave].particion === i) option.selected = true;
                            select.appendChild(option);
                        }
                    }

                    let discoSelect = document.createElement("select");
                    let discos = ['sda', 'sdb', 'sdc', 'sdd'].slice(0, configuracion.nDiscos);
                    if (discosDesdeConfiguracion.length > 0) discos = discosDesdeConfiguracion;//si se han cargado los discos desde la configuraci√≥n, se muestran s√≥lo esos discos en los select para asignar las particiones, aunque si se han cargado los bloques.json con los namespaces de los discos nvme, se mostrar√°n s√≥lo los discos que haya en el bloque json para asignar las particiones, ya que para asignar correctamente las UUIDs a cada partici√≥n es necesario que el nombre del disco y el n√∫mero de partici√≥n correspondan exactamente con los que hay en el bloque json, por ejemplo nvme0n1p1 para la partici√≥n 1 del disco nvme0n1, y si se muestran m√°s discos en el select que no correspondan con los del bloque json, al asignar una partici√≥n a un disco que no corresponda con el bloque json esa partici√≥n no tendr√° asignada correctamente su UUID aunque el nombre del disco y el n√∫mero de partici√≥n sean correctos, por ejemplo si se muestra en el select un disco sda que no corresponde con ning√∫n disco del bloque json y se asigna la partici√≥n 1 a ese disco sda, esa partici√≥n no tendr√° asignada su UUID aunque se llame sda1 porque en el bloque json no hay ning√∫n disco sda ni ninguna partici√≥n sda1, mientras que si se muestra en el select s√≥lo los discos que corresponden con el bloque json y se asigna la partici√≥n 1 al disco nvme0n1 que s√≠ corresponde con un disco del bloque json y tiene una partici√≥n nvme0n1p1 que corresponde con la partici√≥n 1 del disco nvme0n1, esa partici√≥n s√≠ tendr√° asignada su UUID correctamente.
                    if (namespaces.length > 0) discos = namespaces.map(d => d.name);
                    discos.forEach(disco => {
                        let option = document.createElement("option");
                        option.value = disco;
                        option.innerText = /*"sd" +*/ disco;
                        if (particion.nombre === "EFI" && disco !== discos[0]) return;
                        if (particion[clave].disco === disco) option.selected = true;
                        discoSelect.appendChild(option);
                        if (namespaces.length > 0 && particion[clave].disco === disco) {
                            //alert(disco)
                            let numOption = 0;
                            let particionDiscoUUID = '';
                            namespaces.filter(d => d.name === disco)[0].children.forEach((p, i) => {
                                //alert(JSON.stringify(p));
                                particionDiscoUUID = p.uuid;
                                option = document.createElement("option");
                                option.value = i + 1;
                                option.innerText = i + 1;
                                if (particion[clave].particion === i + 1) option.selected = true;
                                select.appendChild(option);
                                numOption++;
                            });
                            if (numOption === 1) {
                                particion[clave].UUID = particionDiscoUUID;
                                particion[clave].particion = 1;
                            }
                        }
                    });

                    discoSelect.onchange = () => {
                        particion[clave].disco = discoSelect.value;
                        document.getElementById("error").innerText = '';
                        //if(configuracion.usarUUID) alert('Si ha cambiado el disco y est√° usando UUIDs, debe volver a cargar el archivo particiones.txt para actualizar las UUIDs asignadas.');
                        particion[clave].UUID = null;
                        label2.innerText = particion[clave].UUID ? ' UUID: ' + particion[clave].UUID : ' UUID: (no asignada)';
                        let iAc = indexActual, tabAc = tabActual;
                        actualizarDiscos();
                        mostrarMenu(iAc, tabAc);

                    };

                    let checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.checked = particion[clave].activa;

                    select.onchange = () => {//alert(select.value)
                        particion[clave].particion = parseInt(select.value);
                        document.getElementById("error").innerText = '';
                        //if(configuracion.usarUUID) alert('Si ha cambiado la partici√≥n y est√° usando UUIDs, debe volver a cargar el archivo particiones.txt para actualizar las UUIDs asignadas.');
                        particion[clave].UUID = null;
                        if (namespaces.length > 0) {//alert(particion[clave].disco+select.value+'-'+particion[clave].disco+JSON.stringify(namespaces.filter(d => d.name === particion[clave].disco)[0].children.filter(p => p.name === particion[clave].disco+select.value)[0]));//si hay namespaces asignamos el disco al cambiar la particion porque en nvme el numero de particion no es fijo para cada disco
                            particion[clave].UUID = namespaces.filter(d => d.name === particion[clave].disco)[0].children.filter(p => p.name === particion[clave].disco + select.value)[0].uuid;
                        }
                        label2.innerText = particion[clave].UUID ? ' UUID: ' + particion[clave].UUID : ' UUID: (no asignada)';
                    }
                    checkbox.onchange = () => {
                        particion[clave].activa = checkbox.checked;
                        if (clave === 'particionWIN' && !particion[clave].activa) {
                            //si desactiva windows desactiva las particiones de recuperaci√≥n
                            particion['particionRES'].activa = false;
                            particion['particionRES2'].activa = false;
                            document.getElementById(particion.nombre + '_tab').click();// = particion.nombre + '_tab';
                        }
                        if (clave === 'particionMAX' && !particion[clave].activa) {
                            //si desactiva MAX desactiva la particion swap
                            particion['particionSWAP'].activa = false;
                            document.getElementById(particion.nombre + '_tab').click();

                        }
                        document.getElementById("error").innerText = '';
                    }

                    div.appendChild(label);
                    div.appendChild(discoSelect);
                    div.appendChild(select);
                    if (/*clave !== 'particionEFI' && clave !== 'particionSRPBACKUP' &&*/ clave !== 'particionSRP') div.appendChild(checkbox);
                    let label2 = document.createElement("label");
                    label2.innerText = particion[clave].UUID ? ' UUID: ' + particion[clave].UUID : ' UUID: (no asignada)';
                    div.appendChild(label2);

                    if (clave === 'particionSRPBACKUP') {
                        let label = document.createElement("label");
                        label.innerText = 'user: madrid => clave: ';
                        let parrafo = document.createElement("p");

                        parrafo.appendChild(label);
                        parrafo.appendChild(contrasenna);
                        div.appendChild(parrafo);
                        label = document.createElement("label");
                        label.innerText = 'superuser: consejeria => clave: ';
                        parrafo = document.createElement("p");

                        parrafo.appendChild(label);
                        parrafo.appendChild(ccontrasenna);
                        label = document.createElement("label");
                        label.innerText = ' Encriptado grub.pbkdf2: ';

                        parrafo.appendChild(label);
                        parrafo.appendChild(hashedPassword);
                        div.appendChild(parrafo);
                    }
                    menu.appendChild(div);
                }
                //contenidoTab[index]=menu;
            });
            //}else{menu=contenidoTab[index]}
            menu.classList.add("visible");
        }

        function comprobarErrores() {
            //alert(JSON.stringify(configuracion));
            let recuerdaCargarUUIDs = '';
            document.getElementById("cargarConfResultado").style.visibility = 'hidden';
            if (configuracion.usarUUID && !seHaCargadoUUIDsFile) {
                let seguir = confirm('Si se va a usar UUIDs y no se ha cargado desde el archivo particiones.txt');
                if (!seguir) return false;
            }
            //se pone activa srp para tener en document las partes de las contrase√±a
            mostrarMenu(1, srp_tab)
            let errorMsg = "";
            let activas = new Set();
            let UUIDs = new Set();
            configuracion.particiones.forEach(particion => {
                Object.keys(particion).forEach(clave => {
                    if (clave !== "nombre") {
                        let id = particion[clave].disco + particion[clave].particion;
                        if (particion[clave].activa) {
                            if (activas.has(id)) {
                                //alert(JSON.stringify(particion)+'\n'+JSON.stringify(activas));
                                errorMsg += `Conflicto: La partici√≥n ${id} est√° duplicada.\n`;
                            }
                            activas.add(id);
                            if (configuracion.usarUUID) {
                                if (!particion[clave].UUID) {
                                    recuerdaCargarUUIDs = '\nRecuerda cargar las UUIDs desde el archivo particiones.txt si has cambiado alguna partici√≥n o disco.\n';
                                    errorMsg += `Error: La partici√≥n ${id} no tiene UUID asignada.\n`;
                                } else {
                                    if (UUIDs.has(particion[clave].UUID)) {
                                        errorMsg += `Conflicto: La UUID ${particion[clave].UUID} est√° duplicada.\n`;
                                    }
                                    UUIDs.add(particion[clave].UUID);
                                }
                            }
                        }
                    }
                });
            });

            let efi = configuracion.particiones.find(p => p.nombre === "EFI");
            if (efi.activa && namespaces.length > 0 && efi.particionEFI.disco !== namespaces[0].name/*'a'*/) {
                errorMsg += "Error: La partici√≥n EFI debe estar en el disco '" + namespaces[0].name + "'.\n";
            }
            if (!estaEncriptada) generatePBKDF2();//solo si no se ha encriptado previamente se lanza
            //comprobamos que si usammos windows legacy esta activada la primera particion de recuperacion
            let pWin = configuracion.particiones[2].particionWIN;
            let pResW = configuracion.particiones[2].particionRES;
            let pEFI = configuracion.particiones[0].particionEFI;
            let pMAX = configuracion.particiones[3].particionMAX;
            let pSWAP = configuracion.particiones[3].particionSWAP;
            if (!pEFI.activa && pWin.activa && !pResW.activa) {
                errorMsg += 'Error: En arranque legacy es la primera particion reservada para el sistiema la que windows utiliza para arrancar.\n\tDebe por tanto estar seleccionada.\n';

            }
            if (!pWin.activa && !pMAX.activa) {
                errorMsg += 'Error: Debe estar activa al menos una partici√≥n de Windows o MAX.\n';
            }
            if (!pMAX.activa && pSWAP.activa) {
                errorMsg += 'Error: No puede estar activa la partici√≥n SWAP si no lo est√° la partici√≥n MAX.\n';

            }
            if (pResW.activa) {
                if (!pWin.activa) {
                    errorMsg += 'Error: La particion de recuperaci√≥n de windows no puede estar activa si la particion de windows no lo est√°.\n';
                }
            }
            let pResW2 = configuracion.particiones[2].particionRES2;
            if (pResW2.activa) {
                if (!pWin.activa) {
                    errorMsg += 'Error: La segunda particion de recuperaci√≥n de windows no puede estar activa si la particion de windows no lo est√°.\n';
                }
                if (!pResW.activa) {
                    errorMsg += 'Error: La segunda particion de recuperaci√≥n de windows no puede estar activa si la primera no lo est√°.\n';
                }
            }
            if (pWin.activa && !pResW.activa) {
                errorMsg += 'Error: Windows tiene siempre la primera particion de recuperaci√≥n activa.\n';
            }
            //alert(!pEFI.activa&&pWin.activa&&!pResW.activa+'****')
            //alert(errorMsg || "Configuraci√≥n v√°lida.\n" + JSON.stringify(configuracion));
            errorMsg = recuerdaCargarUUIDs + errorMsg;
            document.getElementById("error").innerText = errorMsg || "Configuraci√≥n v√°lida.\n" + JSON.stringify(configuracion);
            document.getElementById('discos').innerText = '';
            return errorMsg === '';
        }

        cargarTabs();

        function cargarImagenes(zip) {
            return new Promise((resolve, reject) => {
                const folder = zip.folder("srp/fondos");
                const imageFiles = ["fondo.png", "fondo2.png", "fondo2.png", "fondo3.png", "fondogene.png", "fondorest.png", "fondoesp.png"]; // Nombres de im√°genes esperados
                let loadedImages = 0;

                imageFiles.forEach(imgName => {
                    fetch(`fondos/${imgName}`)
                        .then(response => response.blob())
                        .then(blob => {
                            const reader = new FileReader();
                            reader.onload = function () {
                                folder.file(imgName, reader.result.split(",")[1], { base64: true });
                                loadedImages++;
                                if (loadedImages === imageFiles.length) resolve();
                            };
                            reader.readAsDataURL(blob);
                        })
                        .catch(() => {
                            loadedImages++;
                            if (loadedImages === imageFiles.length) resolve();
                        });
                });
            });
        }

        function generarZip() {
            if (!comprobarErrores()) {//si hay errores se avisa y no generamos srp.zip
                alert('Revisa los errores encontrados en la configuraci√≥n');
                return;
            }
            let zip = new JSZip();
            // en folder incluiremos los scripts de autorun que la base est√° en la variable autorun que se carga de autorun.js
            let folder = zip.folder("autorun");
            let ddiscos = ['a', 'b', 'c', 'd'];
            let pWin = configuracion.particiones[2].particionWIN;
            let pResW = configuracion.particiones[2].particionRES;
            let pResW2 = configuracion.particiones[2].particionRES2;
            let pMAX = configuracion.particiones[3].particionMAX;
            let pSWAP = configuracion.particiones[3].particionSWAP;
            let pEFI = configuracion.particiones[0].particionEFI;
            let textoSWAP = 'no_hay_swap';
            if (pSWAP.activa) textoSWAP = '/dev/' + pSWAP.disco + pSWAP.particion;
            let pSRP = configuracion.particiones[1].particionSRP;
            //Solo SRP sin SRPBACKUP se gestiona en srp.js con la etiqueta ##tcopytoram## que se sustituye por copytoram o nada
            //la variable tcopytoram, y montando la particion SRP en mnt/SRP y mnt/SRPBACKUP, en autorun.js no se precisan cambios.
            //el arranque de system rescue cd se hace en menuavanzado y la generacion de BackUpas con la opcion "copytoram" para que 
            // SRP sea escribible, no es necesario que lo sea en las restauraciones.
            let pSRPBACKUP = configuracion.particiones[1].particionSRPBACKUP.activa ? configuracion.particiones[1].particionSRPBACKUP : configuracion.particiones[1].particionSRP;
            let tcopytoram = configuracion.particiones[1].particionSRPBACKUP.activa ? '' : 'copytoram ';
            ///
            let ngrupos = 0;
            [pWin, pMAX, pSWAP].forEach(grupo => {
                if (grupo.activa) ngrupos++;
            });
            ngWin = 1;//al menos estar√≠a la de windows si se llega a crear
            if (pResW.activa) ngWin++;
            if (pResW2.activa) ngWin++;
            //para m√°x se deja fijo 2 ya que aunque no haya swap se gestiona con no_hay_swap en el device
            //para efi dejamos fijo 1
            autorun.forEach(archivo => {
                if (archivo.nombre === 'autorun0') {
                    //El archivo autorun0 se hace todo desde aqu√≠ no se usa la plantilla de autorun.js     
                    let aux = `# version: SRP v2.0 #\n\n# Nombre de la particion que contiene los backups y los menus de GRUB;
BACKUP_DEV="/dev/${pSRPBACKUP.disco + pSRPBACKUP.particion}"
# SRP_DEV Particion que contiene el sofware de Sytem Rescue CD, que ejercuta los procesos
SRP_DEV="/dev/${pSRP.disco + pSRP.particion}"
# Punto de montaje de la partici√≥n que contendr√° los backups
BACKUP_MNT="/mnt/SRPBACKUP"
# Verificar si el directorio /mnt/backup existe
if [ -d "$BACKUP_MNT" ]; then
    echo "El directorio '$BACKUP_MNT' ya existe."
else
    echo "El directorio '$BACKUP_MNT' no existe. Cre√°ndolo ahora..."
    mkdir -p "$BACKUP_MNT" # Crea el directorio (incluyendo directorios padres si no existen)
    if [ $? -eq 0 ]; then
        echo "Directorio creado exitosamente."
    else
        echo "Hubo un error al crear el directorio."
    fi
fi
# N√∫mero de grupos de particiones
NG=${ngrupos}
###############################################################################
# N√∫mero de particiones que tiene el grupo x
#Gx_NP=n
# Etiqueta del grupo. Esta etiqueta se mostrar√° en los menus, en mensajes tipo:
# Restaurar <ETIQUETA>...
# Generar backup de <ETIQUETA>...
#Gx_MENU="Linux"
#------------------------------------------------------------------------------
# Nombre dispositivo
#GxPn_DEV="/dev/sda1"
# Etiqueta que se muestra en los menus
#GxPn_MENU="MAX"
# Etiqueta del sistema de ficheros
#GxPn_LABEL="MAX65"
# Sistema de ficheros
#GxPn_FS="ntfs"
###############################################################################\n`;

                    if (pWin.activa) {
                        aux += `G1_NP=${ngWin}
G1_MENU="Windows"\n`;
                        if (pResW.activa) {
                            aux += `#------------------------------------------------------------------------------
G1P1_DEV="/dev/${pResW.disco + pResW.particion}"
G1P1_LABEL_MENU=""
G1P1_LABEL="Reservado para el sistema"
G1P1_FS="ntfs"\n`;
                        }
                        aux += `#------------------------------------------------------------------------------
G1P2_DEV="/dev/${pWin.disco + pWin.particion}"
G1P2_LABEL_MENU="Windows"
G1P2_LABEL="Windows"
G1P2_FS="ntfs"\n`;
                        if (pResW2.activa) {
                            aux += `#------------------------------------------------------------------------------
G1P3_DEV="/dev/${pResW2.disco + pResW2.particion}"
G1P3_MENU=""
G1P3_LABEL="Reservado para el sistema 2"
G1P3_FS="ntfs"\n`;
                        }
                        aux += `###############################################################################\n`;
                    }
                    if (pMAX.activa) {
                        aux += `G2_NP=2
G2_MENU="MAX"
#------------------------------------------------------------------------------
G2P1_DEV="/dev/${pMAX.disco + pMAX.particion}"
G2P1_LABEL_MENU="MAX"
G2P1_LABEL="MAX12"
G2P1_FS="ext4"
#------------------------------------------------------------------------------
# Asignar a G2P2_DEV la etiqueta "no_hay_swap" para indicar que no existe swap.
G2P2_DEV="${textoSWAP}"
G2P2_LABEL_MENU=""
G2P2_LABEL="swap"
G2P2_FS="swap"
###############################################################################\n`;
                    }
                    aux += `#--No usamos la particion datos.
#G3_NP=1
#G3_MENU="Datos"
#------------------------------------------------------------------------------
#G3P1_DEV="/dev/sda5"
#G3P1_LABEL_MENU="Datos"
#G3P1_LABEL="Datos"
#G3P1_FS="ntfs"
###############################################################################
${pEFI.activa ? '' : '#'}G4_NP=1
${pEFI.activa ? '' : '#'}G4_MENU="EFI"
#------------------------------------------------------------------------------
${pEFI.activa ? '' : '#'}G4P1_DEV="/dev/${pEFI.disco + pEFI.particion}"
${pEFI.activa ? '' : '#'}G4P1_LABEL_MENU="EFI"
${pEFI.activa ? '' : '#'}G4P1_LABEL="EFI"
${pEFI.activa ? '' : '#'}G4P1_FS="fat32"
###############################################################################              
`;
                    folder.file(archivo.nombre, aux);
                } else {
                    if (['autorun1', 'autorun2', 'autorun3', 'autorun8', 'funciones.sh'].includes(archivo.nombre)) {
                        folder.file(archivo.nombre, archivo.contenido);
                    } else {
                        if (['autorun4', 'autorun6'].includes(archivo.nombre) && pWin.activa) {
                            texto = archivo.contenido;
                            if (!pResW.activa) {
                                texto = reemplazarTexto(texto, 'particion recuperacion windows', '');
                            }
                            if (!pResW2.activa) {
                                texto = reemplazarTexto(texto, 'segunda particion recuperacion windows', '');
                                if (['autorun4'].includes(archivo.nombre)) texto = reemplazarTexto(texto, '2 segunda particion recuperacion windows', '');

                            }

                            folder.file(archivo.nombre, texto);
                        }
                        if (['autorun5', 'autorun7'].includes(archivo.nombre) && pMAX.activa) {
                            folder.file(archivo.nombre, archivo.contenido);
                        }
                        if (['autorun9', 'autorunA'].includes(archivo.nombre) && pEFI.activa) {
                            folder.file(archivo.nombre, archivo.contenido);
                        }
                        if (['autorunB'].includes(archivo.nombre)) {
                            texto = archivo.contenido;
                            if (!pWin.activa) {
                                texto = reemplazarTexto(texto, 'entrada windows', '');
                            }
                            if (!pMAX.activa) {
                                texto = reemplazarTexto(texto, 'entrada MAX', '');
                            }
                            if (!pEFI.activa) {
                                texto = reemplazarTexto(texto, 'entrada EFI', '');
                            }
                            folder.file(archivo.nombre, texto);
                        }
                    }
                }
            });
            ///creamos el configurador de grub en su sitio que enlaza con el menuprincipal de SRP
            let folderboot = zip.folder("boot/grub");
            folderboot.file('grub.cfg', 'configfile /srp/menus/menuprincipal.cfg');

            //creamos los men√∫ns de SRP en el arranque con grub EFI la base esta en los variable menus que proviene de srp.js
            let folder2 = zip.folder("srp/menus");

            menus.forEach(archivo => {
                //alert('procesando ' + archivo.nombre);
                let texto = archivo.contenido;
                if (archivo.nombre === 'menuprincipal.cfg') { //alert('siii'

                    let aux = `set pSRP=(hd${numDisco(pSRP.disco)},${pSRP.particion})  # Definir la variable
export pSRP       # Hacerla global
${pEFI.activa ? '' : '#'}set pEFI=(hd${numDisco(pEFI.disco)},${pEFI.particion})  
${pEFI.activa ? '' : '#'}export pEFI   
#set pWIN=(hd0,3)  
#export pWIN
set pMAX=(hd${numDisco(pMAX.disco)},${pMAX.particion})  
export pMAX

set superusers="consejeria"
export superusers
password_pbkdf2 consejeria ${document.getElementById('hashedPassword').value}
password madrid ${configuracion.users[0].pass}
`;
                    let legacyWIN = `menuentry "Iniciar Windows" --unrestricted {
set root=(hd${numDisco(pResW.disco)},${pResW.particion})
chainloader +1
}`;

                    let legacyMAX = `menuentry "Iniciar MAX" --unrestricted {
set root=(hd${numDisco(pMAX.disco)},${pMAX.particion})
chainloader +1
}`;
                    //si esta activa usar UUID las cambiamos por:
                    if (configuracion.usarUUID) {
                        legacyWIN = `menuentry "Iniciar Windows" --unrestricted {
set root=(hd${numDisco(pResW.disco)},${pResW.particion})
if [ x$feature_platform_search_hint = xy ]; then
  search --no-floppy --fs-uuid --set=root --hint-bios=hd${numDisco(pResW.disco)},gpt${pResW.particion} --hint-efi=hd${numDisco(pResW.disco)},gpt${pResW.particion} --hint-baremetal=ahci${numDisco(pResW.disco)},gpt${pResW.particion}  ${pResW.UUID}
else
  search --no-floppy --fs-uuid --set=root ${pResW.UUID}
fi
chainloader +1
}`;
                        legacyMAX = `menuentry "Iniciar MAX" --unrestricted {
set root=(hd${numDisco(pMAX.disco)},${pMAX.particion})
if [ x$feature_platform_search_hint = xy ]; then
  search --no-floppy --fs-uuid --set=root --hint-bios=hd${numDisco(pMAX.disco)},gpt${pMAX.particion} --hint-efi=hd${numDisco(pMAX.disco)},gpt${pMAX.particion} --hint-baremetal=ahci${numDisco(pMAX.disco)},gpt${pMAX.particion}  ${pMAX.UUID}
else
  search --no-floppy --fs-uuid --set=root ${pMAX.UUID}
fi
chainloader +1
}`;
                    }
                    let auxEFI = `if [ x$feature_platform_search_hint = xy ]; then
  search --no-floppy --fs-uuid --set=root --hint-bios=hd${numDisco(pEFI.disco)},gpt${pEFI.particion} --hint-efi=hd${numDisco(pEFI.disco)},gpt${pEFI.particion} --hint-baremetal=ahci${numDisco(pEFI.disco)},gpt${pEFI.particion}  ${pEFI.UUID}
else
  search --no-floppy --fs-uuid --set=root ${pEFI.UUID}
fi`;
                    let UEFI_WIN = `menuentry "Iniciar Windows" --unrestricted --class windows --class os {
insmod part_gpt
insmod fat
set root=$pEFI
${auxEFI}
chainloader /EFI/Microsoft/Boot/bootmgfw.efi
}`;
                    let UEFI_MAX = `menuentry "Iniciar MAX" --unrestricted --class max --class gnu-linux --class gnu --class os {
insmod part_gpt
insmod fat
set root=$pEFI
${auxEFI}
chainloader /EFI/ubuntu/grubx64.efi
}`;

                    texto = reemplazarTexto(texto, 'variables globales grub', aux)
                    if (!pEFI.activa) {
                        texto = reemplazarTexto(texto, 'entrada windows', legacyWIN)
                        texto = reemplazarTexto(texto, 'entrada MAX', legacyMAX)
                    } else if (configuracion.usarUUID) {
                        texto = reemplazarTexto(texto, 'entrada windows', UEFI_WIN)
                        texto = reemplazarTexto(texto, 'entrada MAX', UEFI_MAX)
                    }
                    if (!pWin.activa) texto = reemplazarTexto(texto, 'entrada windows', '')
                    if (!pMAX.activa) texto = reemplazarTexto(texto, 'entrada MAX', '')
                }
                if (archivo.nombre === 'menucopia1.cfg') {
                    if (!pWin.activa) texto = reemplazarTexto(texto, 'entrada windows', '')
                    if (!pMAX.activa) texto = reemplazarTexto(texto, 'entrada MAX', '')
                    if (!pMAX.activa || !pWin.activa) texto = reemplazarTexto(texto, 'entrada windows y MAX', '')
                    if (!pEFI.activa) texto = reemplazarTexto(texto, 'entrada EFI', '')
                }
                if (archivo.nombre === 'menucopia2.cfg') {
                    if (!pWin.activa) {
                        texto = reemplazarTexto(texto, 'entrada windows', '');
                        texto = reemplazarTexto(texto, 'entrada windows2', '');
                        //alert(texto+'\n'+archivo.nombre+'\n'+archivo.contenido)
                    }
                    if (!pMAX.activa) {
                        texto = reemplazarTexto(texto, 'entrada MAX', '');
                        texto = reemplazarTexto(texto, 'entrada MAX2', '');
                    }
                    if (!pMAX.activa || !pWin.activa) {
                        texto = reemplazarTexto(texto, 'entrada windows y MAX', '');
                        texto = reemplazarTexto(texto, 'entrada windows y MAX2', '');
                    }
                    if (!pEFI.activa) {
                        texto = reemplazarTexto(texto, 'entrada EFI', '');
                        texto = reemplazarTexto(texto, 'entrada EFI2', '');
                    }
                }
                if (archivo.nombre === 'menuespecial.cfg') {
                    if (!pWin.activa) {
                        texto = reemplazarTexto(texto, 'entrada windows', '');
                    }
                    if (!pMAX.activa) {
                        texto = reemplazarTexto(texto, 'entrada MAX', '');;
                    }
                }
                if (configuracion.usarUUID) {
                    if (texto.indexOf('set root=$pSRP' > -1)) {
                        let fragmentos = texto.split('set root=$pSRP')
                        let nuevoTexto = '';
                        let n = fragmentos.length - 1;
                        fragmentos.forEach((fragmento, indice) => {
                            if (indice < n) {
                                nuevoTexto += fragmento + `set root=$pSRP
if [ x$feature_platform_search_hint = xy ]; then
  search --no-floppy --fs-uuid --set=root --hint-bios=hd${numDisco(pSRP.disco)},gpt${pSRP.particion} --hint-efi=hd${numDisco(pSRP.disco)},gpt${pSRP.particion} --hint-baremetal=ahci${numDisco(pSRP.disco)},gpt${pSRP.particion}  ${pSRP.UUID}
else
  search --no-floppy --fs-uuid --set=root ${pSRP.UUID}
fi`;
                            } else {
                                nuevoTexto += fragmento;
                            }
                        });
                        texto = nuevoTexto;
                    };
                }
                //solo SRP sin SRPBACKUP se gestiona en srp.js con la etiqueta ##tcopytoram## que se sustituye por copytoram o nada
                if (['menuavanzado.cfg', 'menugenewin2.cfg', 'menugenewinmax2.cfg', 'menugenemax2.cfg', 'menugeneEFI2.cfg', 'menuespecial.cfg']) {
                    let partes = texto.split('##tcopytoram##');
                    if (partes.length > 1) {
                        texto = partes.join(tcopytoram);
                    }
                }
                ///a√±adimos el archivo si procede
                if (['menuavanzado.cfg', 'menucopia1.cfg', 'menucopia2.cfg', 'menuprincipal.cfg', 'menuespecial.cfg'].includes(archivo.nombre)) {
                    folder2.file(archivo.nombre, texto);
                } else {
                    if (pWin.activa && ['menugenewin2.cfg', 'menurestwin1.cfg', 'menurestwin2.cfg'].includes(archivo.nombre)) {
                        folder2.file(archivo.nombre, texto);
                    }
                    if (pMAX.activa && ['menugenemax2.cfg', 'menurestmax1.cfg', 'menurestmax2.cfg'].includes(archivo.nombre)) {
                        folder2.file(archivo.nombre, texto);
                    }
                    if (pWin.activa && pMAX.activa && ['menugenewinmax2.cfg', 'menurestwinmax1.cfg', 'menurestwinmax2.cfg'].includes(archivo.nombre)) {
                        folder2.file(archivo.nombre, texto);
                    }
                    if (pEFI.activa && ['menugeneEFI2.cfg', 'menurestEFI1.cfg', 'menurestEFI2.cfg'].includes(archivo.nombre)) {
                        folder2.file(archivo.nombre, texto);
                    }
                }
            });
            /**
             * Aqui a√±adimos los elementos de la carpeta herramientas, no se ha usado plantilla a diferencia de autorun.js y srp.js
             */
            let folder3 = zip.folder("herramientas");

            //primero a√±adimos a dicha carpeta la configuraci√≥n con que hemos generado menus de srp, scripts de autorun
            //y las contrase√±as de madrid y consejer√≠a para uso en el futuro.
            folder3.file('configuraci√≥n.txt', JSON.stringify(configuracion));


            let herramienta = `#!/bin/bash

## Crea las carpetas necesarias y monta en ella las particiones que contienen ${pEFI.activa ? 'EFI, ' : ''}SRPBACUP y SRP.

${pEFI.activa ? '' : '#'}#creamos la carpeta EFI para contener la particion EFI
${pEFI.activa ? '' : '#'}mkdir /mnt/EFI
${pEFI.activa ? '' : '#'}#montamos la particion EFI en esa carpeta
${pEFI.activa ? '' : '#'}mount /dev/${pEFI.disco + pEFI.particion} /mnt/EFI

#creamos la carpeta SRPBACKUP para contener la particion SRPBACKUP
mkdir /mnt/SRPBACKUP
#montamos la particion SRPBACKUP en esa carpeta
mount /dev/${pSRPBACKUP.disco + pSRPBACKUP.particion} /mnt/SRPBACKUP

#creamos la carpeta SRP para contener la particion SRP
mkdir /mnt/SRP
#montamos la particion SRP en esa carpeta
mount /dev/${pSRP.disco + pSRP.particion} /mnt/SRP`;
            folder3.file('Monta' + (pEFI.activa ? 'EFI_' : '') + 'SRPBACUP_SRP.sh', herramienta);
            herramienta = pEFI.activa ? `#!/bin/bash

# Creamos la entrada en arranque EFI para arrancar con grub desde la partici√≥n SRPBACKUP:
#    -Esa entrada aparecera con etiqueta SRP en la lista de entradas del firmware;
#    -Se crea dentro de la carpeta EFI de la particion EFI, la carpeta SRP para esta entrada.

grub-install --target=x86_64-efi --recheck --efi-directory=/mnt/EFI/ --boot-directory=/mnt/SRPBACKUP/boot/ --bootloader-id=SRP
`: `#!/bin/bash

# instalamos grup para arrancar con grub desde la partici√≥n SRPBACKUP en el mbr del disco a.
grub-install --no-floppy --root-directory=/mnt/SRPBACKUP /dev/sda
`;


            folder3.file(pEFI.activa ? 'CrearEntradaGrubEFI.sh' : 'InstalrGrubEnMBRsda.sh', herramienta);

            herramienta = `#!/bin/bash

## Ponemos en primer lugar del orden de arranque con el comando efibootmgr el arranque con SRP. 

# Obtener el n√∫mero de la nueva entrada cuyo nombre comienza por SRP creada, eliminando el asterisco
NEW_ENTRY=$(efibootmgr | grep -E "^Boot[0-9A-Fa-f]{4}\\* SRP" | awk '{print $1}' | sed -E 's/^Boot([0-9A-Fa-f]{4})\\*/\\1/')

if [ -z "$NEW_ENTRY" ]; then
    echo "No se encontr√≥ una entrada que contenga ' SRP'"
    exit 1
fi

# Obtener las entradas actuales de arranque, eliminando posibles asteriscos
EXISTING_ENTRIES=$(efibootmgr | grep -E '^Boot[0-9A-Fa-f]{4}' | sed -E 's/^Boot([0-9A-Fa-f]{4})\\*.*/\\1/')

# Crear una nueva lista de orden de arranque, eliminando duplicados
ORDER="$NEW_ENTRY,$(echo "$EXISTING_ENTRIES" | tr ' ' '\\n' | grep -v "^$NEW_ENTRY$" | tr '\\n' ',' | sed 's/,$//')"

# Cambiar el orden de arranque
echo "Estableciendo nuevo orden de arranque: $ORDER"
sudo efibootmgr -o $ORDER

# Ver el nuevo orden de arranque
echo "Nuevo orden de arranque:"
efibootmgr
`;
            //Solo si hay arranque UEFI
            if (pEFI.activa) {
                folder3.file('PonerPrimeraLaEntradaSRPenEFI.sh', herramienta);
            }
            if (pMAX.activa) {
                let folder4 = zip.folder("herramientas/MAX");
                herramienta = `#!/bin/bash

## Si hemos clonado MAX desde otro equipo, habr√° que cambiar el nombre de equipo en MAX
## ya que al ser un clon mantendr√° el del equipo de que procede.

# Comprobar si el script se ejecuta como superusuario
if [ "$(id -u)" -ne 0 ]; then
  echo "Este script debe ejecutarse como superusuario. Usa sudo."
  exit 1
fi

# Solicitar el nuevo nombre del equipo
read -p "Introduce el nuevo nombre para el equipo: " nuevo_nombre

# Cambiar el nombre del host en /etc/hostname
echo "$nuevo_nombre" > /etc/hostname

# Cambiar el nombre del host en /etc/hosts (asegurarse de que la direcci√≥n 127.0.1.1 coincida con el nombre del host)
sed -i "s/127.0.1.1.*/127.0.1.1   $nuevo_nombre/" /etc/hosts

# Aplicar el cambio de nombre del host
#hostname "$nuevo_nombre"
hostnamectl set-hostname "$nuevo_nombre"

# Confirmar que el cambio fue exitoso
echo "‚úÖ El nombre del equipo ha sido cambiado a '$nuevo_nombre'."`;

                folder4.file('cambiarNombreEquipo.sh', herramienta);
                herramienta = `#!/bin/bash

## Normalmente en un aula de informatica los equipos de windows estan en una red
## dentro de un grupo de trabajo, con este escript se pretende facilitar que tras
## la instalacion de MAX los equipos configuren la red y el grupo de trabajo.

# Comprobar si el script se ejecuta como superusuario
if [ "$(id -u)" -ne 0 ]; then
  echo "Este script debe ejecutarse como superusuario. Usa sudo."
  exit 1
fi

# Solicitar el nombre del grupo de trabajo
read -p "Introduce el nuevo nombre del grupo de trabajo: " nuevo_grupo_trabajo

# Comprobar si Samba est√° instalado
if ! dpkg -l | grep -q samba; then
  echo "Samba no est√° instalado. Instalando Samba..."
  apt update && apt install -y samba
fi

# Modificar el archivo de configuraci√≥n de Samba (/etc/samba/smb.conf)
sed -i "s/^workgroup = .*/workgroup = $nuevo_grupo_trabajo/" /etc/samba/smb.conf

# Reiniciar el servicio de Samba para aplicar los cambios
systemctl restart smbd

# Confirmar que el cambio fue exitoso
echo "El grupo de trabajo ha sido cambiado a '$nuevo_grupo_trabajo'."`;
                folder4.file('cambiar_grupo_trabajo.sh', herramienta);
                //Si solo se usa la particion SRP tanto para SystenRescueCD como para las carpetas coipia1, copia2,
                //no se crea partici√≥n para SRPBACKUP y por tanto no hay que ocultarla.
                let textoSRPBACKUP = '" "/dev/' + pSRPBACKUP.disco + pSRPBACKUP.particion + '"'
                if ((pSRP.disco + pSRP.particion) === (pSRPBACKUP.disco + pSRPBACKUP.particion)) textoSRPBACKUP = '"';
                //                let herraux = ('"/dev/' + pSRP.disco + pSRP.particion + '" "/dev/' + pSRPBACKUP.disco + pSRPBACKUP.particion + '"');
                let herraux = ('"/dev/' + pSRP.disco + pSRP.particion + textoSRPBACKUP);
                if (pWin.activa) {
                    herraux += (' "/dev/' + pWin.disco + pWin.particion + '"');
                    if (pResW.activa) herraux += (' "/dev/' + pResW.disco + pResW.particion + '"');
                    if (pResW2.activa) herraux += (' "/dev/' + pResW2.disco + pResW2.particion + '"');
                }

                herramienta = `#!/bin/bash
## Tras la instalaci√≥n de MAX, se montan autom√°ticamente las particiones que usamos para administrar SRP${pWin.activa ? ` y
## las propias de windows, `: ',\n## '}como son particiones que los usuarios normales no es conveniente que pueda ni siquiera ver
## ya que si se hicieran cambios no autorizados podr√≠an da√±ar el funcionamiento ${pWin.activa ? 'de windows y/o el' : 'del'} sistema de 
## restauraci√≥n, con este script se pretende que queden sin montar y por tanto ocultas a los usuarios de MAX.
## Si el administrador del equipo precisara acceder a ellas conociendo sus discos y particiones de la configuraci√≥n
## del disco/discos que se creo en el momento de elaborar el SRP (tambien se pueden ver usando gparted), puede proceder 
## a montarlas manualmente dentro de MAX.

# Aseg√∫rate de que el script se ejecute como root
if [ "$(id -u)" -ne 0 ]; then
    echo "Este script debe ejecutarse como root. Usa sudo."
    exit 1
fi

# Lista de particiones a ocultar
particiones=(${herraux})
# Procesar cada partici√≥n
for particion in "`+ '${particiones[@]}' + `"; do
    # Obtener UUID y sistema de archivos
    UUID=$(blkid -s UUID -o value "$particion" 2>/dev/null)
    FSTYPE=$(blkid -s TYPE -o value "$particion" 2>/dev/null)

    # Verificar si la partici√≥n existe
    if [ -z "$UUID" ] || [ -z "$FSTYPE" ]; then
        echo "‚ùå La partici√≥n $particion no existe o no tiene un UUID v√°lido. Se omitir√°."
        continue
    fi

    # Verificar si ya est√° en /etc/fstab
    if grep -q "UUID=$UUID" /etc/fstab; then
        echo "‚úî La partici√≥n $particion (UUID=$UUID) ya est√° en /etc/fstab. No se modificar√°."
    else
        echo "‚ûï Agregando $particion (UUID=$UUID) a /etc/fstab para evitar montaje autom√°tico..."
        echo "#La partici√≥n $particion se incluye para no ser montada en el arranque." >> /etc/fstab
        echo "UUID=$UUID none $FSTYPE noauto 0 0" >> /etc/fstab
    fi

    # Desmontar si ya est√° montada
    if findmnt -rno SOURCE "$particion" > /dev/null; then
        echo "üîπ Desmontando $particion..."
        umount "$particion"
    else
        echo "‚úî $particion ya est√° desmontada."
    fi
done

echo "‚úÖ Configuraci√≥n completada. Las particiones de SRP ${pWin.activa ? 'y  Windows ' : ''}ya no se montar√°n autom√°ticamente."
`;
                folder4.file('ocultar_particiones_SRP' + (pWin.activa ? '_windows' : '') + '.sh', herramienta);
            }
            let folder5 = zip.folder("herramientas/clonado");
            if (pEFI.activa) {
                //let folder5 = zip.folder("herramientas/clonado");
                herramienta = `#!/bin/bash

# Si se clona el disco ya configurado con carpetas para los distintos arranques en la 
# carpeta EFI en el nuevo equipo adem√°s del disco ya clonado es necesario crear
# en el firmware al menos la entrada para SRP para que desde ella mediante los men√∫s 
# nos permita accdeder a los otros SO. (Windows suele crear la suya al arrancar si no
# encuentra una entrada para windows ya configurada y adem√°s la pone como primera, por
# lo que si es as√≠ tras el primer arranque de windows habr√†  que volver a poner como
# primera la entrada SRP usando la herramienta PonerPrimeraLaEntradaSRPenEFI.sh.

# Crea en el firmware del equipo la entrada SRP apuntando a la carpeta EFI/SRP/grubx64.efi
efibootmgr --create --disk /dev/${pEFI.disco} --part ${pEFI.particion} --label "SRP" --loader '\\EFI\\SRP\\grubx64.efi'`;
                folder5.file('CreaEntradaSRPPostClonado.sh', herramienta);
            }
            herramienta = `#!/bin/bash
# ---------------------------------------------------------
# Servidor/Cliente NFS para intercambiar informaci√≥n entre
# los distintos equipos del aula conectados por red.
# El SERVIDOR expone a los clientes la carpeta /mnt/SRPBACKUP
# por defecto se expone en solo lectura (ro).
# los CLIENTES acceden al contenido de la carpeta expuesta en 
# la carpeta /mnt/NFS.
# Una vez actualizado el SO de un equipo y hecha la copia personalizada
# se puede arrancar el servidor NFS en ese equipo y arrancando
# clientes NFS en el resto de los equipos para copiar los archivos
# de la copia personalizada a la carpeta /mnt/SRPBACKUP/copia2 de dichos
# equipos que sustituir√≠a a la version anterior. Restaurando la 
# copia personalizada en cada equipo tendr√≠amos la nueva version del SO
# a falta de configurar el nombre de equipo.
# ---------------------------------------------------------
set -e

MOUNT_SRC="/mnt/SRPBACKUP"
MOUNT_DST="/mnt/NFS"
LABEL="SRPBACKUP"
CLIENT_NET="192.168.1.0/24"

# Opciones de exportaci√≥n
EXPORT_OPTS_RW="rw,sync,no_subtree_check,no_root_squash,fsid=0"
EXPORT_OPTS_RO="ro,sync,no_subtree_check,fsid=0"

# ---------------------------------------------------------
# Utilidades
# ---------------------------------------------------------

detect_client_net() {
  # Interfaz usada para salir a la red
  local IFACE
  IFACE=$(ip route show default 0.0.0.0/0 | awk '{print $5}' | head -n1)

  if [ -z "$IFACE" ]; then
    echo "ERROR: No se pudo detectar la interfaz de red"
    exit 1
  fi

  # IP con prefijo (ej: 192.168.1.50/24)
  local IP_CIDR
  IP_CIDR=$(ip -4 -o addr show dev "$IFACE" | awk '{print $4}' | head -n1)

  if [ -z "$IP_CIDR" ]; then
    echo "ERROR: No se pudo obtener la IP de $IFACE"
    exit 1
  fi

  # Calcular red usando ipcalc si existe, si no, fallback simple
  if command -v ipcalc >/dev/null 2>&1; then
    CLIENT_NET=$(ipcalc -n "$IP_CIDR" | awk -F= '{print $2}')"/`+ '${IP_CIDR#*/}"\n' +
                `  else
    # Fallback simple: asume /24 (muy com√∫n)
    CLIENT_NET="$(echo "$IP_CIDR" | sed 's/\\.[0-9]\\+\\/.*/.0\\/24/')"
  fi
}


show_ip() {
  echo
  echo "IP(s) del servidor:"
  ip -4 -o addr show | awk '{print " - " $2 ": " $4}'
  echo
}

# ---------------------------------------------------------
# Permitiendo servir NFS en firewal SystemRescueCD
# ---------------------------------------------------------
setup_firewall_nfs() {
  echo "Configurando firewall para NFS..."

  iptables -P INPUT DROP
  iptables -P FORWARD DROP
  iptables -P OUTPUT ACCEPT

  iptables -F
  iptables -X

  # Permitir loopback
  iptables -A INPUT -i lo -j ACCEPT

  # Permitir conexiones establecidas
  iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

  # ICMP (ping)
  iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT

  # RPC / NFS
  iptables -A INPUT -p tcp --dport 111 -j ACCEPT
  iptables -A INPUT -p udp --dport 111 -j ACCEPT
  iptables -A INPUT -p tcp --dport 2049 -j ACCEPT
  iptables -A INPUT -p udp --dport 2049 -j ACCEPT
  iptables -A INPUT -p tcp --dport 20048 -j ACCEPT
  iptables -A INPUT -p udp --dport 20048 -j ACCEPT

  echo "Firewall NFS configurado"
}

# ---------------------------------------------------------
# Servidor
# ---------------------------------------------------------
start_server() {
  MODE="$1" # ro | rw
  [ "$MODE" != "rw" ] && MODE="ro"

  echo "=== MODO SERVIDOR ==="

  detect_client_net

  echo "Red detectada autom√°ticamente: $CLIENT_NET"

  systemctl start rpcbind || true
  systemctl start nfs-server || systemctl start nfs || true
#  systemctl stop firewalld || true

  OPTS="$EXPORT_OPTS_RW"
  [ "$MODE" = "ro" ] && OPTS="$EXPORT_OPTS_RO"
  #echo "$MOUNT_SRC $CLIENT_NET(rw,sync,no_subtree_check,no_root_squash)" > /etc/exports
  echo "$MOUNT_SRC $CLIENT_NET(rw,sync,no_subtree_check,no_root_squash)" > /etc/exports
  echo "$MOUNT_SRC $CLIENT_NET($OPTS)" > /etc/exports
  exportfs -rav

  show_ip

  echo "Servidor NFS listo"
  echo "Exportando: $MOUNT_SRC ($MODE)"
  echo
  echo "NO CIERRES ESTA TERMINAL"
}

stop_server() {
  echo "Parando servidor NFS"
  systemctl stop nfs-server
  systemctl is-active nfs-server
  echo "Servidor detenido y limpio"
}

# ---------------------------------------------------------
# Cliente
# ---------------------------------------------------------
start_client() {
  SERVER_IP="$1"
  [ -z "$SERVER_IP" ] && {
    echo "Uso: $0 client <IP_SERVIDOR>"
    exit 1
  }

  echo "=== MODO CLIENTE ==="

  mkdir -p "$MOUNT_DST"

  #mount -t nfs "$SERVER_IP:$MOUNT_SRC" "$MOUNT_DST"
  mount -t nfs -o soft,nolock "$SERVER_IP:$MOUNT_SRC" "$MOUNT_DST"

  echo
  echo "NFS montado en $MOUNT_DST"
  echo "Ya puedes acceder desde el entorno gr√°fico"
}

stop_client() {
  echo "Desmontando cliente: $MOUNT_DST"
  umount "$MOUNT_DST"
}


case "$1" in
  server)
    setup_firewall_nfs
    start_server "$2"
    ;;
  stop-server)
    stop_server
    ;;
  client)
    start_client "$2"
    ;;
  stop-client)
    stop_client
    ;;
  *)
    echo "Uso:"
    echo "  $0 server [ro|rw]"
    echo "  $0 stop-server"
    echo "  $0 client <IP_SERVIDOR>"
    echo "  $0 stop-client"
    exit 1
    ;;
esac
`;
            folder5.file('srp_nfs.sh', herramienta);
            if (pWin.activa) {
                herramienta = `#!/bin/bash
# Este script permite realizar el BACKUP de Windows, la carpeta en que se 
# guarda se define desde el teclado igual que en las opciones ESPECIALES.
# El escript NO funciona en MODO GRAFICO, por lo que se debe ejecutar en una
# TERIMNAL AUTENTICA de TEXTO. 
# Si estamos en modo gr√°fico se puede salir desde el bot√≥n inicio seleccionando
# Log-Out y luego de nuevo Log-Out, o bien con Ctrl+Alt+F2.
#
# Si finalizado el script, queremos seguir en la sesisi√≥n de SystemRescueCD
# antes de que pasen los 30s de espera para reincialr se debe pulsar Ctrl+c
#

if [ -n "$DISPLAY" ]; then
    echo "ERROR: No ejecute este script desde el modo gr√°fico."
    echo "Puede hacer Log-Oou/Log-Out desde el boton inicio o"
    echo "cambie a una consola con Ctrl+Alt+F2 y ejec√∫telo all√≠."
    exit 1
fi

echo "Entorno correcto. Continuando..."
umount /dev/${pWin.disco}${pWin.particion}
cd  /run/archiso/bootmnt/autorun
chmod 755 *
./autorun1
./autorun6
mount /dev/${pWin.disco}${pWin.particion} /mnt/WIN`;
                folder5.file('BackupWin.sh', herramienta);
                herramienta = `#!/bin/bash
# Este script permite RESTAURAR WINDOWS, la carpeta desde la que se restaura
# se define desde el teclado igual que en las opciones ESPECIALES.
# El escript NO funciona en MODO GRAFICO, por lo que se debe ejecutar en una
# TERIMNAL AUTENTICA de TEXTO. 
# Si estamos en modo gr√°fico se puede salir desde el bot√≥n inicio seleccionando
# Log-Out y luego de nuevo Log-Out, o bien con Ctrl+Alt+F2.
#
# Si finalizado el script, queremos seguir en la sesisi√≥n de SystemRescueCD
# antes de que pasen los 30s de espera para reincialr se debe pulsar Ctrl+c
#

if [ -n "$DISPLAY" ]; then
    echo "ERROR: No ejecute este script desde el modo gr√°fico."
    echo "Puede hacer Log-Oou/Log-Out desde el boton inicio o"
    echo "cambie a una consola con Ctrl+Alt+F2 y ejec√∫telo all√≠."
    exit 1
fi

echo "Entorno correcto. Continuando..."
umount /dev/${pWin.disco}${pWin.particion}
cd  /run/archiso/bootmnt/autorun
chmod 755 *
./autorun1
./autorun4
mount /dev/${pWin.disco}${pWin.particion} /mnt/WIN`;
                folder5.file('RestauraWin.sh', herramienta);
            }
            if (pMAX.activa) {
                herramienta = `#!/bin/bash
# Este script permite realizar el BACKUP de Windows, la carpeta en que se 
# guarda se define desde el teclado igual que en las opciones ESPECIALES.
# El escript NO funciona en MODO GRAFICO, por lo que se debe ejecutar en una
# TERIMNAL AUTENTICA de TEXTO. 
# Si estamos en modo gr√°fico se puede salir desde el bot√≥n inicio seleccionando
# Log-Out y luego de nuevo Log-Out, o bien con Ctrl+Alt+F2.
#
# Si finalizado el script, queremos seguir en la sesisi√≥n de SystemRescueCD
# antes de que pasen los 30s de espera para reincialr se debe pulsar Ctrl+c
#

if [ -n "$DISPLAY" ]; then
    echo "ERROR: No ejecute este script desde el modo gr√°fico."
    echo "Puede hacer Log-Oou/Log-Out desde el boton inicio o"
    echo "cambie a una consola con Ctrl+Alt+F2 y ejec√∫telo all√≠."
    exit 1
fi

echo "Entorno correcto. Continuando..."
umount /dev/${pMAX.disco}${pMAX.particion}
cd  /run/archiso/bootmnt/autorun
chmod 755 *
./autorun1
./autorun7
mount /dev/${pMAX.disco}${pMAX.particion} /mnt/MAX`;
                folder5.file('BackupMax.sh', herramienta);
                herramienta = `#!/bin/bash
# Este script permite RESTAURAR MAX, la carpeta desde la que se restaura
# se define desde el teclado igual que en las opciones ESPECIALES.
# El escript NO funciona en MODO GRAFICO, por lo que se debe ejecutar en una
# TERIMNAL AUTENTICA de TEXTO. 
# Si estamos en modo gr√°fico se puede salir desde el bot√≥n inicio seleccionando
# Log-Out y luego de nuevo Log-Out, o bien con Ctrl+Alt+F2.
#
# Si finalizado el script, queremos seguir en la sesisi√≥n de SystemRescueCD
# antes de que pasen los 30s de espera para reincialr se debe pulsar Ctrl+c
#

if [ -n "$DISPLAY" ]; then
    echo "ERROR: No ejecute este script desde el modo gr√°fico."
    echo "Puede hacer Log-Oou/Log-Out desde el boton inicio o"
    echo "cambie a una consola con Ctrl+Alt+F2 y ejec√∫telo all√≠."
    exit 1
fi

echo "Entorno correcto. Continuando..."
umount /dev/${pMAX.disco}${pMAX.particion}
cd  /run/archiso/bootmnt/autorun
chmod 755 *
./autorun1
./autorun5
mount /dev/${pMAX.disco}${pMAX.particion} /mnt/MAX`;
                folder5.file('RestauraMax.sh', herramienta);
            }
            let folder6 = zip.folder("herramientas/VirtualBox");
            herramienta = `#!/bin/bash
# En las pruebas mediante m√°quinas virtuales de VirtualBox
# para poder intercambiar informaci√≥n entre el host y las
# m√°quinas virtuales se puede utilizar las CARPETAS COMPARTIDAS 
# de VirtualBox.
#
# Para visualizar la carpeta compartida en VirtualBox en SRP
# arrancando SystemRescueCD, la carpeta compartida se comparte
# con el nombre SRP_HOST en la cofiguracion de la m√°quina de 
# VirtualBox y aparece montada en el SystemRescueCD de la m√°quina
# virtual en la carpeta  /mnt/host cuando se ejecuta este script.

mkdir -p /mnt/host
mount -t vboxsf SRP_HOST /mnt/host
echo "La carpeta compartida con el nombre SRP_HOST en VirtualBox estar√° montada en: /mnt/host"`;
            folder6.file('CarpetaCompartidaVirtualBoxSRP.sh', herramienta);


            //CARGAMOS LOS FONDOS DE LOS MENUS
            cargarImagenes(zip).then(() => {
                zip.generateAsync({ type: "blob" }).then(function (content) {
                    let a = document.createElement("a");
                    a.href = URL.createObjectURL(content);
                    a.download = "srp.zip";
                    a.click();
                });
            });
        }
        const numDisco = (disco) => {

            if (namespaces.length > 0) {
                for (i = 0; i < namespaces.length; i++) {
                    if (namespaces[i].name === disco) {
                        return i;
                    }
                }
            } else {
                return 0;
            }
            //namespace.filter(d => d.name === disco).map(d => d.numero)[0];
            /*switch (letra) {
                case 'a': return 0;
                case 'b': return 1;
                case 'c': return 2;
                case 'd': return 3;
                case 'e': return 4;
                case 'f': return 5;
                case 'g': return 6;
                case 'h': return 7;
            }*/
        }
        function reemplazarTexto(inputText, name, replacement) {
            //let inputText = document.getElementById("inputText").value;
            //let name = document.getElementById("searchName").value;
            //let replacement = document.getElementById("replaceText").value;

            let marcaIni = "##--" + name + "--##";
            let marcaFin = "##--fin " + name + "--##";
            let aux = inputText.split(marcaIni);
            let cabecera = aux[0];//alert(cabecera)
            aux = aux[1].split(marcaFin);
            let cola = aux[1];
            let result = cabecera + marcaIni + '\n' + replacement + '\n' + marcaFin + cola;

            //let regex = new RegExp("##--" + name + "--##([\\s\S]*?)##--fin " + name + "--##", "g");
            //let result = inputText.replace(regex, `##--${name}--##\n${replacement}\n##--fin ${name}--##`);

            //document.getElementById("outputText").value = result;
            return result
        }

        //para generar la encriptacion de la contrase√±a, es un proceso lento que se lanza en paralelo y se chequea que esta encriptada mediante este semaforo

        let estaEncriptada = false
        function generatePBKDF2() {
            // Obtenci√≥n de los valores introducidos
            const password = document.getElementById('password').value;
            const iterations = 10000;// parseInt(document.getElementById('iterations').value, 10);
            const keylen = 64;// parseInt(document.getElementById('keylen').value, 10);

            if (password === '') {
                alert("Por favor, ingresa una contrase√±a.");
                return;
            }

            //const saltHex = "C40F196D0D81371D66A88443FC8697C1E7695B88F33A9B371C4FF379D7380622F8C828292B617868B4A8746D30AFE25B37606C1D8E015EE49F5415F822D8D18E"; // Salt en HEX
            let simbolos = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
            let saltHex = '';
            for (let i = 0; i < 128; i++) {
                let aux = Math.floor(16 * Math.random())
                saltHex += simbolos[aux];
            }
            //const iterations = 10000;
            const keySizeBytes = keylen//64; // 64 bytes para SHA512

            // Convertir salt de HEX a WordArray (formato requerido por CryptoJS)
            const salt = CryptoJS.enc.Hex.parse(saltHex);

            // Generar clave PBKDF2 en hexadecimal
            const derivedKey = CryptoJS.PBKDF2(password, salt, {
                keySize: keySizeBytes / 4, // CryptoJS usa "palabras" de 32 bits, 64 bytes = 16 palabras
                iterations: iterations,
                hasher: CryptoJS.algo.SHA512
            });

            // Convertir clave derivada a HEX y asegurarse de que est√© en may√∫sculas
            const derivedKeyHex = derivedKey.toString(CryptoJS.enc.Hex).toUpperCase();

            // Formato final igual a GRUB
            const grubHash = `grub.pbkdf2.sha512.${iterations}.${saltHex}.${derivedKeyHex}`;


            document.getElementById('hashedPassword').value = grubHash;
            document.getElementById('hashedPassword').style.visibility = 'visible';
            //document.getElementById('result').style.display = 'block';
            estaEncriptada = true;
        }
        //funcion para ver que las contrse√±as solo sean letras y numeros
        function validarTexto(input) {
            // Expresi√≥n regular que permite solo letras (may√∫sculas y min√∫sculas) y n√∫meros
            const regex = /^[A-Za-z0-9]+$/;

            // Verifica si el valor cumple con la expresi√≥n regular
            return regex.test(input);
        }

    </script>
</body>

</html>