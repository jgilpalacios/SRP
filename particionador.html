<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>OEM GPT Partition Tool PRO</title>

    <style>
        body {
            font-family: Arial;
            background: #f4f6f8;
            margin: 20px
        }

        .disk {
            background: white;
            padding: 15px;
            margin-bottom: 30px;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08)
        }

        svg {
            width: 100%;
            height: 55px;
            margin-bottom: 10px
        }

        .partition-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 6px
        }

        .new-part {
            display: flex;
            gap: 10px;
            margin-top: 6px;
            align-items: center
        }

        button {
            padding: 6px 12px;
            margin-top: 10px;
            cursor: pointer
        }

        .free-info {
            font-weight: bold;
            margin-left: 10px
        }
    </style>
</head>

<body>

    <h2 style="text-align: center;">Herramienta para particionar discos GPT.</h2>
    <p style="color:rgb(5, 5, 67); text-align: center;">Útil para crear las particiones necesarias para instalar SRP en varios equipos iguales creados con la mimsma maqueta.</p>
    <p style="text-align: justify;">Abre una consola en el escritorio y ejecuta la orden:<br>
        <br><b>lsblk -J -b -o
            NAME,KNAME,PATH,TYPE,TRAN,SIZE,MODEL,SERIAL,FSTYPE,MOUNTPOINT,UUID,PARTUUID,LABEL,START,LOG-SEC,PHY-SEC >
            bloques.json</b><br>
        <br>el archivo bloques.json tiene la información de los discos y particiones del sistema,
        Cárgalo en esta herramienta para crear un script (<b>particionador.sh</b>) que ejecutado en una terminal, genere espacio libre
        a partir de una partición grande presente en un disco, reduciéndola por su final y en el espacio liberado 
        se puede crear nuevas particiones que se precisen.(si el equipo tiene varios discos, se puede generar espacio a partir de una particion por disco)<br>
    </p>
    Boton de carga de bloques.json<input type="file" id="fileInput">
    <div id="disks"></div>
    <button onclick="generateScript()">Generar el script particionador.sh</button>
    <p style="color:darkblue; text-align: justify;" >Tras ejecutar el script particionador.sh, habrá creado las particiones configuradas, si deseamos que en los demás equipos se creen con las mismas UUIDs que en este, deberemos obtener un nuevo <b>bloques.json</b>. Ejecutando de nuevo la orden lsblk ..., si cargamos el nuevo archivo bloques.json obtenido con el botón siguiente en el <b>navegador ya configurado</b> obtendremos el archivo <b>particionadorUUIDs_clone.sh</b>. Ejecutando ese script en equipos clon de este nos creara las mismas nuevas particiones con los mismos UUIDs y PartUUIDs (a diferencia de particionador.sh en que los UUIDs y PartUUIDs se asignanal azar).<br>
    Botón para cargar el bloques.json nuevo y <button onclick="generateCloneScriptUNO()">Generar script particionador con las UUIDs iguales del primer equipo</button>
    </p>
    <p style="color:rgb(79, 4, 4); text-align: justify;" >
        Al descargar <b>particionador.sh</b> se descarga a la vez <b>Estado.json</b> un archivo con la información de bloques.json y los datos que introdujimos para configurar particiones a redimensionar y nuevas a crear. Para <u>generar particionadorUUIDs_clone.sh se precisa que el navegador esté configurado</u> y si por error recargamos la página antes de leer el nuevo archivo bloques.json se perdería esa información. Para evitar que se tuviera que rehacer manualmente <b>se puede recuperar el navegador <u>completamente configurado</u> cargando <u>Estado.json</u></b> con el siguiente botón.<br>
    Carga estado guardado: <input type="file" id="fileInputLoadState">
    </p>
    <p style="color:red; text-align: justify;" >
            <b>⚠️ ADVERTENCIA</b>: Esta herramienta genera scripts (particionador.sh y particionadorUUIDs_clone.sh) que <b>cuando <u>se ejecutan</u></b> modifican las particiones del disco. Ese proceso puede ocasionar pérdida de datos. Es necesario que <b>se haya creado una copia de seguridad de los discos</b> mediante una herramienta de clonado como clonezilla o similar.<br> 
            <span style="color:darkgreen"><b>Generar con esta herramienta los scripts</b>, que solo contienen texto con ordenes basch, <b>no tiene ningun peligro sobre los discos</b>.</span> Las precauciones se deben tomar <b>al ejecutarlos</b>.<br>
            <span style="color:darkgreen">Es muy recomendable, antes de proceder con los equipos reales, realizar la generación de los scripts y su ejecución en máquinas virtuales configuradas como los equipos reales. De esta manera nos familiarizaremos con en uso de la herramienta, los pasos a seguir y ver si los efectos sobre el sistema de archivios virtual es el esperado.</span>
    </p >
    <script>
        //para clonar
        let originalState = null
        let clonedState = null
        //fin para clonar

        let data
        let selected = null
        let todosSelected = {};
        let newParts = {}
        //let partActivada=''

        // ---------------- UTILIDADES ----------------
        //todosSelected[disk.name] = { disk, part, input }
        const guardaConfiguracion = () => {

            localStorage.setItem("todosSelected", JSON.stringify(todosSelected))
            localStorage.setItem("newParts", JSON.stringify(newParts))
        }

        function bytesToMiB(b) { return Math.floor(b / 1024 / 1024) }

        function getSeparator(name) {
            if (name.startsWith("nvme") || name.startsWith("mmc"))
                return "p"
            return ""
        }

        function getLastPartNumber(disk) {
            if (!disk.children) return 0
            let nums = disk.children.map(p => {
                const m = p.name.match(/(\d+)$/)
                return m ? parseInt(m[1]) : 0
            })
            return Math.max(...nums)
        }

        function getFsColor(fs) {
            switch (fs) {
                case "ext4": return "#4CAF50"
                case "ntfs": return "#2196F3"
                case "vfat": return "#FF9800"
                case "swap": return "#9C27B0"
                default: return "#9E9E9E"
            }
        }

        function drawRect(svg, x, width, fill, stroke, strokeWidth = 0) {
            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect")
            rect.setAttribute("x", x + "%")
            rect.setAttribute("width", width + "%")
            rect.setAttribute("height", "40")
            rect.setAttribute("rx", "8")
            rect.setAttribute("ry", "8")
            rect.setAttribute("fill", fill)
            rect.setAttribute("stroke", stroke)
            rect.setAttribute("stroke-width", strokeWidth)
            svg.appendChild(rect)
        }

        // ---------------- CARGA ----------------

        document.getElementById("fileInput").addEventListener("change", e => {
            const reader = new FileReader()
            reader.onload = evt => {
                //reiniciamos todo:
                //para clonar
                originalState = null
                clonedState = null
                //fin para clonar

                data = null
                selected = null
                todosSelected = {};
                newParts = {}
                data = JSON.parse(evt.target.result);
                data.blockdevices.forEach(d => {
                    if (d.type === "disk" && d.children)
                        d.children.sort((a, b) => a.start - b.start)
                })
                render()
            }
            reader.readAsText(e.target.files[0])
        })

        document.getElementById("fileInputLoadState").addEventListener("change", e => {
            const reader = new FileReader()
            reader.onload = evt => {
                if(data) {
                    if(!confirm("Cargar un estado guardado perderá los cambios no guardados actuales. ¿Desea continuar?")) {
                        return
                    }
                }
                //reiniciamos todo:
                //para clonar
                originalState = null
                clonedState = null
                //fin para clonar

                data = null
                selected = null
                todosSelected = {};
                newParts = {}

                const savedState = JSON.parse(evt.target.result)
                data = savedState.data || data
                originalState = JSON.parse(JSON.stringify(data))
                data.blockdevices.forEach(d => {
                    if (d.type === "disk" && d.children)
                        d.children.sort((a, b) => a.start - b.start)
                })
                render();
                //Añadimos las selecciones y nuevas particiones guardadas al estado actual
                let estadoValores = savedState.estadoValores || {}
                for (let diskName in estadoValores) {
                    let partName = estadoValores[diskName].partName;
                    let radio = document.getElementById('radio_' + partName);
                    radio.checked = true;
                    radio.dispatchEvent(new Event("click", { bubbles: true }));
                    let input = document.getElementById('input_' + partName);
                    input.value = estadoValores[diskName].newSize;
                    input.dispatchEvent(new Event("input", { bubbles: true }));
                    let nuevas = estadoValores[diskName].nuevas || [];
                    nuevas.forEach(nueva => {
                        let butonAdd = document.getElementById('add_' + diskName);
                        butonAdd.dispatchEvent(new Event('click', { bubbles: true }));
                        let select = document.getElementById(`fs_${nueva.name}`);
                        select.value = nueva.fs;
                        document.getElementById(`size_${nueva.name}`).value = nueva.size;
                        document.getElementById(`label_${nueva.name}`).value = nueva.label;
                        document.getElementById(`size_${nueva.name}`).dispatchEvent(new Event("input", { bubbles: true }));
                        document.getElementById(`label_${nueva.name}`).dispatchEvent(new Event("input", { bubbles: true }));
                        //select.dispatchEvent(new Event("change", { bubbles: true }));
                    })
                }

               
            }
            reader.readAsText(e.target.files[0])
        })

        //para dejar de usar un disco que se seleccionó por error
        const removeDisk = (name) => {
            if (todosSelected[name]) {
                if (!confirm("¿Desea dejar de usar el disco " + name + "? Se perderán los cambios planificados en la partición " + todosSelected[name].part.name + ".")) {
                    return;
                }
                const input = document.getElementById(`input_${todosSelected[name].part.name}`);
                input.value = "";
                const radio = document.getElementById(`radio_${todosSelected[name].part.name}`);
                //radio.dispatchEvent(new MouseEvent('click', { bubbles: true }));
                radio.checked = false;
                //radio.dispatchEvent(new MouseEvent('click', { bubbles: true }));
                document.querySelectorAll(".partition-row span").forEach(s => {
                            if (s.getAttribute("disco") === name)
                                s.style.display = "none"
                        })
                delete todosSelected[name];
                if (newParts[name]) newParts[name].forEach(p => p.element.remove())
                delete newParts[name];
                const disk = data.blockdevices.find(d => d.name === name);
                redrawDisk(disk)
            }
        }

        // ---------------- RENDER ----------------
        let maxSize = 0;
        function render() {
            const container = document.getElementById("disks")
            container.innerHTML = ""

            data.blockdevices.forEach(disk => {
                if (disk.type !== "disk") return

                const diskDiv = document.createElement("div")
                diskDiv.className = "disk"

                diskDiv.innerHTML = `<h3>${disk.path} (${bytesToMiB(disk.size)} MiB)</h3>`

                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg")
                svg.setAttribute("data-disk", disk.name)
                diskDiv.appendChild(svg)

                disk.children?.forEach(part => {
                    const sizeMiB = bytesToMiB(part.size)

                    const row = document.createElement("div")
                    row.className = "partition-row";
                    let visbilidad = ''
                    if (!(part.fstype === 'ntfs' || part.fstype === 'ext4')) visbilidad = 'style="visibility:hidden"'
                    row.innerHTML = `
        <input type="radio" id="radio_${part.name}" name="resize-${disk.name}" ${visbilidad}>
        ${part.path} (${part.fstype || "sin fs"}) ${sizeMiB} MiB
        <span id="span_${part.name}" style="display:none">
          Nuevo tamaño MiB:
          <input id="input_${part.name}" type="number" min="1" style="width:80px">
          <span class="free-info" id="info_${part.name}"></span>
          No usar este disco: <button type="button" id="removeDisck_${part.name}" onclick="removeDisk('${disk.name}')">❌</button>
        </span>
      `

                    const radio = row.querySelector("input")
                    const span = row.querySelector("span")
                    span.setAttribute("disco", disk.name)
                    const input = row.querySelector("input[type=number]")
                    const info = row.querySelector(".free-info")

                    //radio.addEventListener("change", () => {
                    radio.addEventListener("click", () => {
                        //localStorage.setItem("todosSelected", JSON.stringify(todosSelected))
                        //localStorage.setItem("newParts", JSON.stringify(newParts))
                        if(todosSelected[disk.name] && todosSelected[disk.name]&&todosSelected[disk.name].part.name !== part.name&&newParts[disk.name]&&newParts[disk.name].length>0) {
                            if(confirm("Cambiar de partición seleccionada perderá los cambios planificados en la partición actualmente seleccionada " + todosSelected[disk.name].part.name + ". ¿Desea continuar?")) {
                                //alert("Partición seleccionada: " + part.name)
                            } else {
                                document.getElementById(`radio_${todosSelected[disk.name].part.name}`).checked = true;
                                return;    
                            }
                        }
                            //alert("Partición deseleccionada: " + part.name)
                            //delete todosSelected[disk.name]
                        document.querySelectorAll(".partition-row span").forEach(s => {
                            if (s.getAttribute("disco") === disk.name)
                                s.style.display = "none"
                        })
                        span.style.display = "inline"
                        selected = { disk, part, input }
                        
                        if (todosSelected[disk.name]) {
                            if (todosSelected[disk.name].part.name !== part.name) {
                                //alert("Partición seleccionada: " + part.name)
                                if (newParts[disk.name]) newParts[disk.name].forEach(p => p.element.remove())
                                newParts[disk.name] = [];
                                //redrawDisk(disk)
                            }

                        }
                        todosSelected[disk.name] = { disk, part, input }

                        //if (newParts[disk.name]) newParts[disk.name].forEach(p => p.element.remove())
                        //div.remove()
                        //newParts[disk.name] = []
                        redrawDisk(disk)
                    })

                    input.addEventListener("input", () => {//alert(input.value);
                        //radio.dispatchEvent(new MouseEvent('click', { bubbles: true }));
                        const free = sizeMiB - parseInt(input.value || 0)
                        if (free < 0) {
                            info.textContent = "⚠ Excede tamaño"
                            info.style.color = "red"
                        } else {
                            info.textContent = `Libre: ${free} MiB`
                            info.style.color = "green"
                        }
                        redrawDisk(disk)
                    })

                    diskDiv.appendChild(row)
                })

                const addBtn = document.createElement("button")
                addBtn.textContent = "+ Añadir partición"
                addBtn.onclick = () => addPartition(disk, diskDiv)
                addBtn.id = `add_${disk.name}`
                diskDiv.appendChild(addBtn)
                container.appendChild(diskDiv)

                redrawDisk(disk)
            })
        }

        // ---------------- REDIBUJAR SVG ----------------

        function redrawDisk(disk) {
            if (todosSelected[disk.name] && selected && selected.disk.name !== disk.name) {
                const selectedPart = todosSelected[disk.name].part;
                const radio = document.getElementById(`radio_${selectedPart.name}`);
                radio.dispatchEvent(new MouseEvent('click', { bubbles: true }));
            }
            const svg = document.querySelector(`svg[data-disk='${disk.name}']`)
            if (!svg) return

            svg.innerHTML = ""

            const totalMiB = bytesToMiB(disk.size)
            /*if (maxSize < totalMiB)*/ maxSize = totalMiB;
            let xPercent = 0

            const selectedPart = selected?.disk?.name === disk.name ? selected.part : null
            const newSize = selected?.input ? parseInt(selected.input.value || 0) : null
            let Hasta100 = 100;
            let freed = 0;
            let ocupado = 0;
            disk.children?.forEach(part => {
                let sizeMiB = bytesToMiB(part.size)
                if (selectedPart && part.name === selectedPart.name && newSize) {
                    sizeMiB = newSize
                }
                const percent = Math.floor(sizeMiB / maxSize * 100)
                if (percent < 1) Hasta100--;

            })
            //let partOcupadaSize=0;
            let ocupadoAntes = 0;
            newParts[disk.name]?.forEach((p, i) => {
                const base = getLastPartNumber(disk)
                const num = base + i + 1;
                const sep = getSeparator(disk.name)
                let name = disk.name + sep + num;
                let auxSize = document.getElementById(`size_${name}`).value.trim();
                let size = parseInt(auxSize) || 0;
                if (auxSize === "100%") {
                    size = bytesToMiB(selectedPart.size) - newSize - ocupadoAntes;
                }
                ocupadoAntes += size;
                if (!size) return
                const percent = Math.floor(size / maxSize * 100)
                if (percent < 1) Hasta100--;
            })

            disk.children?.forEach(part => {

                let sizeMiB = bytesToMiB(part.size)

                if (selectedPart && part.name === selectedPart.name && newSize) {
                    //alert('siii')
                    //partOcupadaSize = sizeMiB;
                    sizeMiB = newSize
                    let percent = Math.floor(sizeMiB / maxSize * Hasta100);
                    if (percent < 1) percent = 1
                    drawRect(svg, xPercent, percent, getFsColor(part.fstype), "#222")
                    xPercent += percent
                    const np = newParts[disk.name] || [];
                    let sizeCreadas = 0;
                    const base = getLastPartNumber(disk)
                    let num = 0;
                    const sep = getSeparator(disk.name)
                    //let name = disk.path + sep + num;
                    np.forEach((p, i) => {
                        num = base + i + 1;
                        let name = disk.name + sep + num;
                        
                        let auxSize = document.getElementById(`size_${name}`).value.trim();
                        let size = parseInt(auxSize) || 0;
                        if (auxSize === "100%") {
                            size = bytesToMiB(part.size) - newSize - ocupado;
                        }
                        
                        sizeCreadas += size;
                        if (!size) return
                        let percent = Math.floor(size / maxSize * Hasta100);
                        if (percent < 1) percent = 1;
                        ocupado += size;
                        const fs = p.element.querySelector("select").value
                        drawRect(svg, xPercent, percent, getFsColor(fs), "red", 6)
                        xPercent += percent
                    })

                    freed = bytesToMiB(part.size) - newSize - ocupado;

                    if (freed > 0) {
                        //const freedPercent = (freed / totalMiB) * 100
                        let freedPercent = Math.floor(freed / maxSize * Hasta100);
                        if (freedPercent < 1) freedPercent = 1
                        drawRect(svg, xPercent, freedPercent, "#ffffff", "black"/*"#999"*/, 6)
                        xPercent += freedPercent
                    }

                } else {
                    //let percent = (sizeMiB / totalMiB) * 100
                    let percent = Math.floor(sizeMiB / maxSize * Hasta100);
                    if (percent < 1) percent = 1

                    drawRect(svg, xPercent, percent, getFsColor(part.fstype), "#222")
                    xPercent += percent
                    //let freed = 0;
                    //let ocupado = 0;
                }
                let infoElement = document.getElementById(`info_${part.name}`);
                if (infoElement) {
                    //alert("ocupado: " + ocupado + " freed: " + freed+ " MiB particion: " + bytesToMiB(part.size) + " newSize: " + newSize)
                    //infoElement.innerText = `Libre: ${freed} MiB`;
                    if (freed < 0) {
                        infoElement.textContent = "⚠ Excede tamaño"
                        infoElement.style.color = "red"
                    } else {
                        infoElement.textContent = `Libre: ${freed} MiB`
                        infoElement.style.color = "green"
                    }
                }

               
            })

            
        }

        // ---------------- AÑADIR NUEVA ----------------

        function addPartition(disk, diskDiv) {
            if (!todosSelected[disk.name]) {
                alert("Selecciona la partición a redimensionar antes de añadir una nueva partición")
                return
            } else {
                const selectedPart = todosSelected[disk.name].part;
                //const radio = document.getElementById(`radio_${selectedPart.name}`);
                //radio.dispatchEvent(new MouseEvent('click', { bubbles: true }));
                if (!document.getElementById(`input_${selectedPart.name}`).value.trim()) {
                    alert("Indica el nuevo tamaño de la partición a redimensionar antes de añadir una nueva partición")
                    return
                }
                let liberado = bytesToMiB(selectedPart.size) - parseInt(document.getElementById(`input_${selectedPart.name}`).value.trim());
                if (newParts[disk.name]) {
                    let tamañoTotal = 0;
                    let seguimos = true;
                    newParts[disk.name].forEach(p => {
                        const sizeInput = document.getElementById(`size_${disk.name + getSeparator(disk.name) + p.num}`).value.trim();
                        if (sizeInput === '100%') {
                            alert("No se puede añadir una nueva partición si se ha ocupado el 100% del espacio con las presentes.")
                            seguimos = false;
                            return
                        }
                        tamañoTotal += parseInt(sizeInput);

                    })
                    if (!seguimos) return;
                    if (tamañoTotal >= liberado) {
                        alert("La suma de los tamaños de las nuevas particiones ya ocupa todo el espacio disponible")
                        return
                    }
                }
            }

            if (!newParts[disk.name]) newParts[disk.name] = []

            const base = getLastPartNumber(disk)
            const num = base + newParts[disk.name].length + 1
            const sep = getSeparator(disk.name);
            const prev = num - 1;
            if (prev > base) document.getElementById('remove_' + disk.name + sep + prev).style.visibility = "hidden"; //si se añade una nueva partición sin haber puesto tamaño a la anterior se borra la anterior para evitar confusiones, ya que no se puede añadir una nueva partición si la anterior no tiene tamaño
            const name = disk.path + sep + num;
            const idName = disk.name + sep + num;
            const div = document.createElement("div")
            div.className = "new-part"

            div.innerHTML = `
    ${name}
    <select id="fs_${idName}">
      <option>ext4</option>
      <option>ntfs</option>
      <option>vfat</option>
      <option>swap</option>
    </select>
    Tamaño MiB:
    <!--<input type="number" min="1" id="size_${idName}" style="width:80px">-->
    <input type="text" id="size_${idName}" style="width:80px" value="100%">
    Label:
    <input type="text" id="label_${idName}" style="width:100px">
    <button type="button" id="remove_${idName}">❌</button>
  `

            const removeBtn = div.querySelector("button")
            removeBtn.onclick = () => {
                
                const selectedPart = todosSelected[disk.name].part;
                

                if (!document.getElementById(`input_${selectedPart.name}`).value.trim()) {
                    alert("Indica el nuevo tamaño de la partición a redimensionar antes de añadir una nueva partición")
                    return
                }
                if (prev > base) document.getElementById(`remove_${disk.name + sep + prev}`).style.visibility = "visible"; //al eliminar la partición se vuelve a mostrar la anterior
                div.remove()
                //alert(JSON.stringify(newParts[disk.name]))
                //newParts[disk.name] = newParts[disk.name].filter(x => x.element !== div)
                newParts[disk.name].pop()//Elimina la última partición añadida, que es la que se borra al hacer click en el botón de eliminar, ya que no se puede eliminar una partición que no sea la última añadida
                //alert(JSON.stringify(newParts[disk.name]))
                redrawDisk(disk)
            }

            //div.querySelector("input[type=number]").addEventListener("input", () => redrawDisk(disk))
            //alert(`size_${name}`)
            let entradas = div.querySelectorAll("input[type=text]")
            entradas.forEach(ent => {
                if (ent.id === `size_${idName}`) ent.addEventListener("input", () => redrawDisk(disk))
            })
            //.addEventListener("input", () => redrawDisk(disk))
            //div.getElementById(`size_${name}`).addEventListener("input", () => redrawDisk(disk))
            div.querySelector("select").addEventListener("change", () => redrawDisk(disk))

            diskDiv.appendChild(div)
            //alert(div)
            newParts[disk.name].push({ num, element: div })
            //alert('se añaden: ' + JSON.stringify(newParts[disk.name]))

            redrawDisk(disk)
        }

        // ---------------- GENERAR SCRIPT ----------------
        let cabeceraScript = `#!/bin/bash
set -euo pipefail`;
        let ejecucionScript = `# =============================
# EJECUCIÓN
# =============================

require_root
confirm_destruction`;
        let scriptFunciones = `# =============================
# FUNCIONES
# =============================

require_root() {
  if [[ $EUID -ne 0 ]]; then
    echo "ERROR: Debe ejecutarse como root"
    exit 1
  fi
}

check_disk() {
  [[ -b "$1" ]] || { echo "ERROR: Disco $1 no existe"; exit 1; }
}

check_partition_exists() {
    local partition="$1"

    if [[ -b "$partition" ]]; then
        echo "ERROR: La partición $partition YA existe."
        exit 1
    fi

    return 0
}

unmount_if_mounted() {
    local partition="$1"

    if findmnt -rn -S "$partition" > /dev/null 2>&1; then
        echo "La partición $partition está montada. Desmontando..."
        if umount "$partition"; then
            echo "Desmontada correctamente."
            return 0
        else
            echo "Error al desmontar $partition."
            exit 1
        fi
    else
        echo "La partición $partition no está montada."
        return 0
    fi
}

check_partition_NO_exists() {
    local partition="$1"

    if [[ -b "$partition" ]]; then
        return 0
    fi
    
    echo "ERROR: La partición $partition NO existe."
    exit 1
}
`;
        let scriptConfirmar = {
            cabecera: `confirm_destruction() {
  echo "=============================================="
  echo "⚠  ADVERTENCIA: Operación potencialmente destructiva"
  echo "Se modificarán los discos:"`, cuerpo: ``, final: `  echo "=============================================="
  read -rp "Escriba 'CONFIRMAR' para continuar: " confirm

  if [[ "$confirm" != "CONFIRMAR" ]]; then
    echo "Abortado."
    exit 1
  fi
}
`}
        function generateScript() {
            let estadoValores = {}
            //todosSelected[disk.name] = {disk, part, input}
            let script = ``;
            //alert("Generando script\n" + JSON.stringify(todosSelected))
            for (let key in todosSelected) {
                //alert("Seleccionado en " + key + ": " + JSON.stringify(todosSelected[key]))
                selected = todosSelected[key];
                if (!selected) { alert("Seleccione partición"); return }

                let disk = selected.disk
                let part = selected.part
                //alert("Partición seleccionada comienza en: " + (part.start * part['log-sec']) + ' y acaba en: ' + ((part.start * part['log-sec']) + (+part.size - 1)))
                let PartIni = part.start * part['log-sec'];
                let PartFin = (part.start * part['log-sec']) + (+part.size - 1);
                let newSize = parseInt(selected.input.value)
                estadoValores[disk.name] = { partName: part.name, newSize: selected.input.value, nuevas: [] };
                //alert('qqqq'+selected.input.id + " = " + selected.input.value+'--'+document.getElementById('radio_'+part.name).checked);
                if (!newSize) { alert("Indique nuevo tamaño"); return }

                let originalMiB = bytesToMiB(part.size)
                let freed = originalMiB - newSize
                if (freed <= 0) { alert("No libera espacio"); return }

                let numMatch = part.name.match(/(\d+)$/)
                if (!numMatch) { alert("Error número partición"); return }
                let partNumber = numMatch[1]
                //alert(JSON.stringify(newParts[disk.name]))
                //alert(part.name + '++' + partNumber + '++' + newSize + '++' + freed + '--' + disk.name + '--' + getSeparator(disk.name))
                let toCreate = newParts[disk.name] || []
                let requested = 0
                toCreate.forEach((p, i) => {

                    //if (i !== toCreate.length - 1)
                    //alert(disk.path + '..' + `size_${disk.name + getSeparator(disk.name) + p.num}`)
                    requested += parseInt(document.getElementById(`size_${disk.name + getSeparator(disk.name) + p.num}`).value.trim())
                    //requested += parseInt(p.element.querySelector("input[type=number]").value || 0)
                })

                if (requested > freed) {
                    alert("Excede espacio disponible")
                    return
                }
                let newSizeMiB = bytesToMiB(part.size) - freed;
                let newSizeMB = Math.floor((part.size - freed * 1024 * 1024) / 1000000);
                let newSizeEnBytes = part.size - freed * 1024 * 1024;
                let textoNTFS = part.fstype === 'ntfs' ? `ntfsresize --size ${newSizeEnBytes} --force ${part.path}` : '';
                //let textoNTFS = part.fstype === 'ntfs' ? `ntfsresize --size ${newSizeMB}M --force ${part.path}` : '';
                //Para redimesion Ext4 aunque se pone en MiB se indica con la sigla M.
                let textoExt4 = part.fstype === 'ext4' ? `resize2fs ${part.path} ${newSizeMiB}M` : '';
                scriptConfirmar.cuerpo += `\n  echo "   - ${disk.path}"`;
                ejecucionScript += `\ncheck_disk "${disk.path}"
check_partition_NO_exists "${disk.path}${getSeparator(disk.name)}${partNumber}"
unmount_if_mounted "${disk.path}${getSeparator(disk.name)}${partNumber}"
`;
                script += `
DISK="${disk.path}"
echo "Redimensionando ${disk.path}${getSeparator(disk.name)}${partNumber}"
# 2️⃣ Verificar filesystem si es ext4${part.fstype === 'ext4' ? `\ne2fsck -f ${disk.path}${getSeparator(disk.name)}${partNumber}` : ''}
# 3️⃣ Reducir el filesystem
${part.fstype === 'ntfs' ? textoNTFS : ''}${part.fstype === 'ext4' ? textoExt4 : ''}
parted --fix "$DISK" unit B resizepart ${partNumber} ${PartFin - (freed * 1024 * 1024)}
partprobe "$DISK"
sleep 2
# 6️⃣ Verificación final${part.fstype === 'ext4' ? `\n#e2fsck -f ${disk.path}${getSeparator(disk.name)}${partNumber}` : ''}

`
                //sgdisk -n 14:204800:409599 "$DISK" los numeros son en sectores, no en MiB, por eso se multiplica por 1024*1024 y se resta a PartFin para que la nueva partición quede al final del espacio liberado
                let newIni = PartFin - (freed * 1024 * 1024) + 1;
                toCreate.forEach((p, i) => {
                    const sectorIni = newIni / part['log-sec'];
                    const size = parseInt(document.getElementById(`size_${disk.name + getSeparator(disk.name) + p.num}`).value.trim());
                    const label = document.getElementById(`label_${disk.name + getSeparator(disk.name) + p.num}`).value.trim() //
                    let sectorFin = sectorIni + (size * 1024 * 1024 / part['log-sec']) - 1;
                    newIni = newIni + (size * 1024 * 1024);
                    const fs = p.element.querySelector("select").value
                    estadoValores[disk.name].nuevas.push({ name: (disk.name + getSeparator(disk.name) + p.num), size: document.getElementById(`size_${disk.name + getSeparator(disk.name) + p.num}`).value.trim(), label: label, fs: fs });
                    //alert(`Creando partición ${p.num} desde sector ${sectorIni} hasta sector ${sectorFin} con tamaño ${size} MiB y label "${label}" y fs ${fs}`)
                    let textoFs = '';
                    if (fs === 'ntfs' || fs === 'vfat') {
                        textoFs = `\nsgdisk -t ${p.num}:0700 "$DISK"`
                        if (label === 'EFI' && fs === 'vfat') textoFs = `\nsgdisk -t ${p.num}:EF00 "$DISK"`
                    }

                    if (i === toCreate.length - 1) {
                        sectorFin = (PartFin + 1) / part['log-sec'] - 1;
                        script += `\necho "Creando partición final"
sgdisk -n ${p.num}:${sectorIni}:${sectorFin} "$DISK"${textoFs}
`
                    } else {
                        script += `\necho "Creando partición ${p.num}"
sgdisk -n ${p.num}:${sectorIni}:${sectorFin} "$DISK"${textoFs}
`
                    }
                    ejecucionScript += `\ncheck_partition_exists  "${disk.path}${getSeparator(disk.name)}${p.num}"`
                    script += `
partprobe "$DISK"
sleep 1
DEV="${disk.path}${getSeparator(disk.name)}${p.num}"
`                   ;
                    textoFs = '';
                    if (label) {
                        if (fs === 'vfat') textoFs = `-n ${label}`;
                        if (fs === 'ntfs') textoFs = `--label ${label}`;
                    }

                    if (fs === "ext4") script += `mkfs.ext4 -F "$DEV"\n`
                    if (fs === "ntfs") script += `mkfs.ntfs --fast ${textoFs} "$DEV"\n`
                    if (fs === "vfat") script += `mkfs.vfat -F32 ${textoFs} "$DEV"\n`
                    if (fs === "swap") script += `mkswap "$DEV"\n`

                    if (label) {
                        if (fs === "ext4") script += `e2label "$DEV" "${label}"\n`
                        //if (fs === "ntfs") script += `ntfslabel "$DEV" "${label}"\n`
                        //if (fs === "vfat") script += `fatlabel "$DEV" "${label}"\n`
                        if (fs === "swap") script += `swaplabel -L "${label}" "$DEV"\n`
                    }
                })
            }
            script += `\necho "FINALIZADO"\n`
            script = cabeceraScript + "\n\n" + scriptFunciones + "\n\n" + scriptConfirmar.cabecera + scriptConfirmar.cuerpo + "\n" + scriptConfirmar.final + "\n\n" + ejecucionScript + "\n\n" + script;
            download(script, "particionador.sh")
            //guardar estado para clonar
            download(JSON.stringify({ newParts: newParts, data, estadoValores }), 'Estado.json')
            //para clonar
            originalState = JSON.parse(JSON.stringify(data))
            alert("Estado base guardado. Ahora puedes aplicar el script y cargar el nuevo JSON para modo CLON.")
            //fin para clonar
        }

        function download(text, name) {
            const blob = new Blob([text], { type: "text/plain" })
            const a = document.createElement("a")
            a.href = URL.createObjectURL(blob)
            a.download = name
            a.click()
        }

        // ---------------- GENERAR SCRIPT CLON ----------------        
        function generateCloneScriptUNO() {

            if (!originalState) {
                alert("Primero debes generar el script inicial.")
                return
            }
            //alert("Selecciona el ....json obtenido con la información de los discos tras haber aplicado el script particionador.sh y de nuevo la orden lsblk -J ... para generar el script de clonación.")
            const input = document.createElement("input")
            input.type = "file"

            input.onchange = e => {
                
                const reader = new FileReader()
                reader.onload = evt => {
                    let cabeceraScript = `#!/bin/bash
set -euo pipefail`;
                    let ejecucionScript = `# =============================
# EJECUCIÓN
# =============================

require_root
confirm_destruction`;
                    let scriptFunciones = `# =============================
# FUNCIONES
# =============================

require_root() {
  if [[ $EUID -ne 0 ]]; then
    echo "ERROR: Debe ejecutarse como root"
    exit 1
  fi
}

check_disk() {
  [[ -b "$1" ]] || { echo "ERROR: Disco $1 no existe"; exit 1; }
}

check_partition_exists() {
    local partition="$1"

    if [[ -b "$partition" ]]; then
        echo "ERROR: La partición $partition YA existe."
        exit 1
    fi

    return 0
}

unmount_if_mounted() {
    local partition="$1"

    if findmnt -rn -S "$partition" > /dev/null 2>&1; then
        echo "La partición $partition está montada. Desmontando..."
        if umount "$partition"; then
            echo "Desmontada correctamente."
            return 0
        else
            echo "Error al desmontar $partition."
            exit 1
        fi
    else
        echo "La partición $partition no está montada."
        return 0
    fi
}

check_partition_NO_exists() {
    local partition="$1"

    if [[ -b "$partition" ]]; then
        return 0
    fi
    
    echo "ERROR: La partición $partition NO existe."
    exit 1
}

check_uuid_conflict() {
  local uuid="$1"
  if blkid -U "$uuid" &>/dev/null; then
    echo "ERROR: Conflicto UUID $uuid"
    exit 1
  fi
}

check_partuuid_conflict() {
  local partuuid="$1"
  if blkid -t PARTUUID="$partuuid" &>/dev/null; then
    echo "ERROR: Conflicto PARTUUID $partuuid"
    exit 1
  fi
}`;
                    let scriptConfirmar = {
                        cabecera: `confirm_destruction() {
  echo "=============================================="
  echo "⚠  ADVERTENCIA: Operación potencialmente destructiva"
  echo "Se modificarán los discos:"`, cuerpo: ``, final: `  echo "=============================================="
  read -rp "Escriba 'CONFIRMAR' para continuar: " confirm

  if [[ "$confirm" != "CONFIRMAR" ]]; then
    echo "Abortado."
    exit 1
  fi
}
`}
                    //todosSelected[disk.name] = {disk, part, input}
                    let script = ``;
                    for (let key in todosSelected) {
                        //alert("Seleccionado en "+key+": "+JSON.stringify(todosSelected[key])) 
                        selected = todosSelected[key];
                        if (!selected) { alert("Seleccione partición"); return }
                        ///PARTE DE PRIMERO
                        let disk = selected.disk
                        let part = selected.part
                        let PartIni = part.start * part['log-sec'];
                        let PartFin = (part.start * part['log-sec']) + (+part.size - 1);
                        let newSize = parseInt(selected.input.value)
                        let originalMiB = bytesToMiB(part.size)
                        let freed = originalMiB - newSize
                        let numMatch = part.name.match(/(\d+)$/)
                        if (!numMatch) { alert("Error número partición"); return }
                        let partNumber = numMatch[1]
                        toCreate = newParts[disk.name] || []
                        let requested = 0
                        toCreate.forEach((p, i) => {
                            if (i !== toCreate.length - 1)
                                requested += parseInt(document.getElementById(`size_${disk.name + getSeparator(disk.name) + p.num}`).value.trim())
                            //requested += parseInt(p.element.querySelector("input[type=number]").value || 0)
                        })
                        let newSizeMB = Math.floor((part.size - freed * 1024 * 1024) / 1000000);
                        let textoExt4 = part.fstype === 'ext4' ? `resize2fs ${part.path} ${newSize}M` : '';
                        //let textoNTFS = part.fstype === 'ntfs' ? `ntfsresize --size ${newSizeMB}M --force ${part.path}` : '';
                        let textoNTFS = part.fstype === 'ntfs' ? `ntfsresize --size ${part.size - freed * 1024 * 1024} --force ${part.path}` : '';
                        scriptConfirmar.cuerpo += `\n  echo "   - ${disk.path}"`;
                        ejecucionScript += `\ncheck_disk "${disk.path}"
check_partition_NO_exists "${disk.path}${getSeparator(disk.name)}${partNumber}"
unmount_if_mounted "${disk.path}${getSeparator(disk.name)}${partNumber}"`;
                        script += `#echo "Modo CLON OEM"

DISK="${disk.path}"
${part.fstype === 'ext4' ? `# 2️⃣ Verificar filesystem si es ext4\ne2fsck -f ${disk.path}${getSeparator(disk.name)}${partNumber}` : ''}
echo "Redimensionando ${disk.path}${getSeparator(disk.name)}${partNumber}"${part.fstype === 'ntfs' ? '\n' + textoNTFS : ''}${part.fstype === 'ext4' ? '\n' + textoExt4 : ''}
parted --fix "$DISK" unit B resizepart ${partNumber} ${PartFin - (freed * 1024 * 1024)}
partprobe "$DISK"
sleep 2

`
                    }

                    ///FINAL DE PARTE DE PRIMERO

                    clonedState = JSON.parse(evt.target.result)

                    //let script = `#!/bin/bash
                    //set -euo pipefail

                    script += `#echo "Modo CLON OEM"
`

                    originalState.blockdevices.forEach(origDisk => {

                        if (origDisk.type !== "disk") return

                        const newDisk = clonedState.blockdevices.find(d => d.name === origDisk.name)
                        if (!newDisk) return

                        const origParts = origDisk.children?.map(p => p.name) || []
                        const newParts = newDisk.children || []

                        newParts.forEach(part => {

                            if (!origParts.includes(part.name)) {

                                const numMatch = part.name.match(/(\d+)$/)
                                if (!numMatch) return

                                const num = numMatch[1]
                                const sep = getSeparator(newDisk.name)

                                script += `
if blkid | grep -q "${part.uuid}"; then
  echo "ERROR: Conflicto UUID ${part.uuid}"
  exit 1
fi
`
                                let sectorIni = part.start;
                                let sectorFin = part.start + (part.size / part['log-sec']) - 1
                                let textoFs = '';
                                if (part.fstype === 'ntfs' || part.fstype === 'vfat') {
                                    textoFs = `\nsgdisk -t ${num}:0700 ${newDisk.path}`
                                    if (part.label === 'EFI' && part.fstype === 'vfat') textoFs = `\nsgdisk -t ${num}:EF00 ${newDisk.path}`
                                }
                                ejecucionScript += `\n
check_partition_exists "/dev/${part.name}"
check_uuid_conflict "${part.uuid}"
check_partuuid_conflict "${part.partuuid}"
`
                                script += `
echo "Creando partición ${part.name}"
sgdisk -n ${num}:${sectorIni}:${sectorFin} ${newDisk.path}${textoFs}
sgdisk -u ${num}:${part.partuuid} ${newDisk.path}
partprobe ${newDisk.path}
sleep 1
`

                                if (part.fstype === "ext4")
                                    script += `mkfs.ext4 -U ${part.uuid} ${newDisk.path}${sep}${num}\n`

                                //iba lo de ntfs antes de la etiqueta en el mkfs, pero al poner la etiqueta ahí no se aplicaba, así que se pone aparte y con --fast para que sea más rápido aunque no tan óptimo

                                if (part.fstype === "vfat") {
                                    let labelSinGion = part.uuid.replace(/-/g, '');
                                    if (part.label) textoFs = `-n ${part.label}`;
                                    else textoFs = '';
                                    script += `mkfs.vfat -F32 ${textoFs} -i ${labelSinGion} ${newDisk.path}${sep}${num}\n`
                                    //script += `mkfs.vfat ${newDisk.path}${sep}${num}\nfatlabel ${newDisk.path}${sep}${num} "${part.label || ""}"\n`
                                    /*if (part.label) {
                                        script += `fatlabel ${newDisk.path}${sep}${num} "${part.label}"\n`
                                    }*/
                                }
                                if (part.fstype === "swap") {
                                    if (part.label) {
                                        script += `swaplabel -L "${part.label}" -U ${part.uuid} ${newDisk.path}${sep}${num}\n`
                                    } else {
                                        script += `mkswap -U ${part.uuid} ${newDisk.path}${sep}${num}\n`
                                    }
                                }
                                if (part.label && part.fstype !== "vfat") {
                                    if (part.fstype === "ext4")
                                        script += `e2label ${newDisk.path}${sep}${num} "${part.label}"\n`
                                    if (part.fstype === "ntfs")
                                        //script += `ntfslabel ${newDisk.path}${sep}${num} "${part.label}"\n`
                                        script += `mkfs.ntfs --fast --label "${part.label}" ${newDisk.path}${sep}${num}\n`
                                }
                                if (part.fstype === "ntfs")
                                    //script += `mkfs.ntfs -f -U ${part.uuid} ${newDisk.path}${sep}${num}\n`
                                    script += `ntfslabel --new-serial=${part.uuid} ${newDisk.path}${sep}${num}\n`


                            }
                        })
                    })

                    script += `echo "CLON FINALIZADO"\n`
                    script = cabeceraScript + "\n\n" + scriptFunciones + "\n\n" + scriptConfirmar.cabecera + scriptConfirmar.cuerpo + "\n" + scriptConfirmar.final + "\n\n" + ejecucionScript + "\n\n" + script;
                    download(script, "particionadorUUIDs_clone.sh")
                }

                reader.readAsText(e.target.files[0])
            }
            //const input = document.createElement("input")
            //input.type = "file"
            if(confirm("Selecciona el JSON obtenido con la información de los discos tras haber aplicado el script particionador.sh y de nuevo la orden lsblk -J ... para generar el script de clonación.")){
                input.click()
            }
        }


        


    </script>
</body>

</html>